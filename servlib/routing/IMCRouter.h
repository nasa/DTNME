/*
 *    Copyright 2022 United States Government as represented by NASA
 *       Marshall Space Flight Center. All Rights Reserved.
 *
 *    Released under the NASA Open Source Software Agreement version 1.3;
 *    You may obtain a copy of the Agreement at:
 * 
 *        http://ti.arc.nasa.gov/opensource/nosa/
 * 
 *    The subject software is provided "AS IS" WITHOUT ANY WARRANTY of any kind,
 *    either expressed, implied or statutory and this agreement does not,
 *    in any manner, constitute an endorsement by government agency of any
 *    results, designs or products resulting from use of the subject software.
 *    See the Agreement for the specific language governing permissions and
 *    limitations.
 */

#ifndef _IMC_ROUTER_H_
#define _IMC_ROUTER_H_

#include "BundleRouter.h"
#include "IMCConfig.h"
#include "IMCRegionGroupRec.h"
#include "RouterInfo.h"
#include "RouteTable.h"


namespace dtn {

class Bundle;
class BundleList;
class IMCRouter;
class RouteEntryVec;
class RouteTable;


typedef std::shared_ptr<IMCRouter> SPtr_IMCRouter;

/**
 * This class is a standalone helper router/thread that handles the special processing to 
 * forward (IMC) multi-destination bundles.  It makes use of static routes either sharing the 
 * RouteTable generated by the Static Router or building its own if a different router type is 
 * in use.
 */
class IMCRouter : public BundleRouter {
public:

    /**
     * IMC Configuration structure
     */
    static IMCConfig imc_config_;

public:
    /**
     * Constructor
     */
    IMCRouter(const char* classname, const std::string& name, SPtr_RouteTable& sptr_route_table);

    /**
     * Destructor.
     */
    virtual ~IMCRouter();

    /**
     * Initiate a clean shutdown of the thread
     */
    virtual void shutdown();

    /**
     * Post/queue an event to be processed
     */
    virtual void post(Bundle* bundle);
    virtual void post(SPtr_BundleEvent& sptr_event);

    /**
     * Hook to ask the router if the bundle can be deleted.
     */
    virtual bool can_delete_imc_bundle(const BundleRef& bundle);

protected:
    /**
     * Main thread function that dispatches events. 
     */
    virtual void run() override;

    /**
     * Event handler overridden from BundleRouter / BundleEventHandler
     * that dispatches to the type specific handlers where
     * appropriate.
     */
    virtual void handle_event(SPtr_BundleEvent& sptr_event) override;
    
    /// @{ Event handlers
    virtual void handle_route_imc_bundle(SPtr_BundleEvent& sptr_event) override;
    virtual void handle_registration_added(SPtr_BundleEvent& sptr_event) override;
    virtual void handle_registration_removed(SPtr_BundleEvent& sptr_event) override;
    virtual void handle_contact_up(SPtr_BundleEvent& sptr_event) override;

    // need these for non-static routers???
    //
    //virtual void handle_link_available(SPtr_BundleEvent& sptr_event) override;
    //virtual void handle_link_created(SPtr_BundleEvent& sptr_event) override;
    //virtual void handle_link_deleted(SPtr_BundleEvent& sptr_event) override;
    //virtual void handle_custody_timeout(SPtr_BundleEvent& sptr_event) override;
    /// @}

    /**
     * Dump the routing state.
     */
    virtual void get_routing_state(oasys::StringBuffer* buf);

    /**
     * Get a tcl version of the routing state.
     */
    virtual void tcl_dump_state(oasys::StringBuffer* buf);

    /**
     * Check if the bundle should be forwarded to the given next hop.
     */
    virtual bool should_fwd_imc(const Bundle* bundle, RouteEntry* route, bool& is_queued);
    
    /**
     * Check if the bundle should be forwarded to the given next hop.
     * Reasons why it would not be forwarded include that it was
     * already transmitted or is currently in flight on the link, or
     * that the route indicates ForwardingInfo::FORWARD_ACTION and it
     * is already in flight on another route.
     */
    virtual bool should_fwd(const Bundle* bundle, RouteEntry* route);

    /**
     * Check the route table entries that match the given bundle and
     * have not already been found in the bundle history. If a match
     * is found, call fwd_to_nexthop on it.
     * Set skip_check_next_hop to true to skip the call to 
     * check_next_hop().
     *
     * @param bundle		the bundle to forward
     *
     * Returns the number of links on which the bundle was queued
     * (i.e. the number of matching route entries.
     */
    virtual int route_bundle(Bundle* bundle);

    /**
     * Routes bundle to the first reachable IMC Router Node in its 
     * region or if node configured then attempts to locate a
     * static router based on the destination EID
     *
     * @param bundle		the bundle to forward
     *
     * Returns the number of links on which the bundle was queued
     * (i.e. the number of matching route entries.
     */
    virtual int route_bundle_as_non_router_node(Bundle* bundle);

    /**
     * Generate sublists of the destinations nodes on per Link basis
     */
    virtual void generate_dest_sublists_per_link(Bundle* bundle);

    /**
     * Queue the bundle on the links with sublists
     */
    virtual int queue_bundle_to_links(Bundle* bundle);

    /**
     * Queue the bundle on an open link to one of the IMC Routers in the home region
     */
    virtual int queue_bundle_to_first_alternate_open_link(Bundle* bundle);

    /**
     * Once a vector of matching routes has been found, sort the
     * vector. The default uses the route priority, breaking ties by
     * using the number of bytes queued.
     */
    virtual void sort_routes(Bundle* bundle, RouteEntryVec* routes);
    
    /**
     * Generate and send an IMC briefing request to all nodes in the home region
     */
    virtual void issue_imc_briefing_request_to_all_nodes_in_region();
    
    /**
     * Generate and send an IMC briefing request to a single node
     */
    virtual void issue_imc_briefing_request_to_single_node(size_t node_num);

protected:

    /// Cache to check for duplicates and to implement a simple RPF check
    /// The routing table
    SPtr_RouteTable sptr_route_table_;

    /// whether running as a spawn of the TableBasedRouter (or other router) which is
    /// managing the routes for the shared RouteTable or whether the IMCRouter created
    /// and is managing its own RouteTable
    bool manage_route_table_ = true;
};

} // namespace dtn

#endif /* _IMC_ROUTER_H_ */
