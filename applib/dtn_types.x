/*
 * NOTE: To make comments appear in the generated files, they must be
 * preceded by a % sign (unlike this one).
 */

%/*
% *    Copyright 2004-2006 Intel Corporation
% * 
% *    Licensed under the Apache License, Version 2.0 (the "License");
% *    you may not use this file except in compliance with the License.
% *    You may obtain a copy of the License at
% * 
% *        http://www.apache.org/licenses/LICENSE-2.0
% * 
% *    Unless required by applicable law or agreed to in writing, software
% *    distributed under the License is distributed on an "AS IS" BASIS,
% *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% *    See the License for the specific language governing permissions and
% *    limitations under the License.
%*/

%
%/**********************************
% * This file defines the types used in the DTN client API. The structures are
% * autogenerated using rpcgen, as are the marshalling and unmarshalling
% * XDR routines.
% */
%
%#include <limits.h>
%#ifndef ARG_MAX
%#define ARG_MAX _POSIX_ARG_MAX
%#endif
%
%/**********************************
% * Constants.
% * (Note that we use #defines to get the comments as well)
% */
%#define DTN_MAX_ENDPOINT_ID 64	    /* max endpoint_id size (bytes) - was 256 */
%#define DTN_MAX_PATH_LEN PATH_MAX	/* max path length */
%//#define DTN_MAX_EXEC_LEN ARG_MAX	/* length of string passed to exec() */
%#define DTN_MAX_EXEC_LEN 1050000	/* length of string passed to exec() */
%#define DTN_MAX_AUTHDATA 1024		/* length of auth/security data*/
%#define DTN_MAX_REGION_LEN 64		/* 64 chars "should" be long enough */
%#define DTN_MAX_BUNDLE_MEM 100000000   /* biggest in-memory bundle is 100MB */
%#define DTN_MAX_BLOCK_LEN 1024         /* length of block data (currently 1K) */
%#define DTN_MAX_BLOCKS 256             /* number of blocks in bundle */

%
%/**
% * Specification of a dtn endpoint id, i.e. a URI, implemented as a
% * fixed-length char buffer. Note that for efficiency reasons, this
% * fixed length is relatively small (256 bytes). 
% * 
% * The alternative is to use the string XDR type but then all endpoint
% * ids would require malloc / free which is more prone to leaks / bugs.
% */
struct dtn_endpoint_id_t {
    opaque	uri[DTN_MAX_ENDPOINT_ID];
};

%
%/**
% * A registration cookie.
% */
typedef u_int dtn_reg_id_t;

%
%/**
% * DTN timeouts are specified in seconds.
% * typedef u_int dtn_timeval_t; // 32-bit systems
% * typedef u_int32_t dtn_timeval_t; // 64-bit systems
% */
typedef u_int dtn_timeval_t;

%
%/**
% * An infinite wait is a timeout of -1.
% */
%#define DTN_TIMEOUT_INF ((dtn_timeval_t)-1)

/**
 * A dtn timestamp contains seconds and a sequence number.
 */

%
%#include "dtn-config.h"
%
%#ifdef HAVE_XDR_U_QUAD_T
%    #define u_hyper u_quad_t
%    #define xdr_u_hyper_t xdr_u_quad_t
%#elif defined(HAVE_XDR_U_INT64_T)
%    #define u_hyper u_int64_t
%    #define xdr_u_hyper_t xdr_u_int64_t
%#else
%    #define u_hyper u_quad_t
%    #define xdr_u_hyper_t xdr_u_quad_t
%#endif

%/**
% * BPv6 uses seconds and BPv7 uses milliseconds
% */
struct dtn_timestamp_t {
    u_hyper secs_or_millisecs;
    u_hyper seqno;
};

%
%/**
% * Specification of a service tag used in building a local endpoint
% * identifier.
% * 
% * Note that the application cannot (in general) expect to be able to
% * use the full DTN_MAX_ENDPOINT_ID, as there is a chance of overflow
% * when the daemon concats the tag with its own local endpoint id.
% */
struct dtn_service_tag_t {
    char tag[DTN_MAX_ENDPOINT_ID];
};

%
%/**
% * Value for an unspecified registration cookie (i.e. indication that
% * the daemon should allocate a new unique id).
% */
const DTN_REGID_NONE = 0;

%
%/**
% * Registration flags are a bitmask of the following:
%
% * Delivery failure actions (exactly one must be selected):
% *     DTN_REG_DROP   - drop bundle if registration not active
% *     DTN_REG_DEFER  - spool bundle for later retrieval
% *     DTN_REG_EXEC   - exec program on bundle arrival
% *
% * Session flags:
% *     DTN_SESSION_CUSTODY   - app assumes custody for the session
% *     DTN_SESSION_PUBLISH   - creates a publication point
% *     DTN_SESSION_SUBSCRIBE - create subscription for the session
% *
% * Other flags:
% *     DTN_DELIVERY_ACKS - application will acknowledge delivered
% *                         bundles with dtn_ack()
% *
% */
enum dtn_reg_flags_t {
    DTN_REG_DROP          = 1,
    DTN_REG_DEFER         = 2,
    DTN_REG_EXEC          = 3,
    DTN_SESSION_CUSTODY   = 4,
    DTN_SESSION_PUBLISH   = 8,
    DTN_SESSION_SUBSCRIBE = 16,
    DTN_DELIVERY_ACKS     = 32 
};

%
%/**
% * Replay flags - behavior when apps bind to an existing registration
% *     DTN_REPLAY_NEW  - [default] deliver new bundles rcvd on reg while not bound
% *     DTN_REPLAY_NONE - don't deliver new bundles rcvd on reg while not bound
% *     DTN_REPLAY_ALL  - deliver _all_ bundles queued up on the reg
% *                       (makes duplicate bundle deliveries possible)
% */
enum dtn_replay_flags_t {
	DTN_REPLAY_NEW = 0,
	DTN_REPLAY_NONE = 1,
	DTN_REPLAY_ALL = 2
};

typedef u_hyper dtn_reg_token_t;

%
%/**
% * Registration state.
% */
struct dtn_reg_info_t {
    dtn_endpoint_id_t 	endpoint;
    dtn_reg_id_t	regid;
    unsigned int	flags;
    unsigned int	replay_flags;
    dtn_timeval_t	expiration;
    bool		init_passive;
    dtn_reg_token_t	reg_token;
    opaque		script<DTN_MAX_EXEC_LEN>;
};

%
%/**
% * Bundle priority specifier.
% *     COS_BULK      - lowest priority
% *     COS_NORMAL    - regular priority
% *     COS_EXPEDITED - important
% *     COS_RESERVED  - TBD
% */
enum dtn_bundle_priority_t {
    COS_BULK = 0,
    COS_NORMAL = 1,
    COS_EXPEDITED = 2,
    COS_RESERVED = 3
};

%
%/**
% * Bundle delivery option flags. Note that multiple options may be
% * selected for a given bundle.
% *     
% *     DOPTS_NONE            - no custody, etc
% *     DOPTS_CUSTODY         - custody xfer
% *     DOPTS_DELIVERY_RCPT   - end to end delivery (i.e. return receipt)
% *     DOPTS_RECEIVE_RCPT    - per hop arrival receipt
% *     DOPTS_FORWARD_RCPT    - per hop departure receipt
% *     DOPTS_CUSTODY_RCPT    - per custodian receipt
% *     DOPTS_DELETE_RCPT     - request deletion receipt
% *     DOPTS_SINGLETON_DEST  - destination is a singleton
% *     DOPTS_MULTINODE_DEST  - destination is not a singleton
% *     DOPTS_DO_NOT_FRAGMENT - set the do not fragment bit
% */
enum dtn_bundle_delivery_opts_t {
    DOPTS_NONE            = 0,
    DOPTS_CUSTODY         = 1,
    DOPTS_DELIVERY_RCPT   = 2,
    DOPTS_RECEIVE_RCPT    = 4,
    DOPTS_FORWARD_RCPT    = 8,
    DOPTS_CUSTODY_RCPT    = 16,
    DOPTS_DELETE_RCPT     = 32,
    DOPTS_SINGLETON_DEST  = 64,
    DOPTS_MULTINODE_DEST  = 128,
    DOPTS_DO_NOT_FRAGMENT = 256
};

%
%/**
% * Extension block flags. Note that multiple flags may be selected
% * for a given block.
% *
% *     BLOCK_FLAG_NONE          - no flags
% *     BLOCK_FLAG_REPLICATE     - block must be replicated in every fragment
% *     BLOCK_FLAG_REPORT        - transmit report if block can't be processed
% *     BLOCK_FLAG_DELETE_BUNDLE - delete bundle if block can't be processed
% *     BLOCK_FLAG_LAST          - last block
% *     BLOCK_FLAG_DISCARD_BLOCK - discard block if it can't be processed
% *     BLOCK_FLAG_UNPROCESSED   - block was forwarded without being processed
% */
enum dtn_extension_block_flags_t {
    BLOCK_FLAG_NONE          = 0,
    BLOCK_FLAG_REPLICATE     = 1,
    BLOCK_FLAG_REPORT        = 2,
    BLOCK_FLAG_DELETE_BUNDLE = 4,
    BLOCK_FLAG_LAST          = 8,
    BLOCK_FLAG_DISCARD_BLOCK = 16,
    BLOCK_FLAG_UNPROCESSED   = 32
};
typedef enum dtn_extension_block_flags_t dtn_extension_block_flags_t;

%
%/**
% *	   BPQ extension block type
% */
%
%#define DTN_BPQ_BLOCK_TYPE 0x0B
%
%/**
% * BPQ Extension block kind.
% *
% *     BPQ_BLOCK_KIND_QUERY				- query bundles
% *     BPQ_BLOCK_KIND_RESPONSE				- response bundles
% *     BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG	- response bundles that should not be cached unless complete
% *     BPQ_BLOCK_KIND_PUBLISH				- publish bundles - treated like response except local storage
% */
%
enum dtn_bpq_extension_block_kind_t {
    BPQ_BLOCK_KIND_QUERY = 0x00,
    BPQ_BLOCK_KIND_RESPONSE = 0x01,
    BPQ_BLOCK_KIND_RESPONSE_DO_NOT_CACHE_FRAG = 0x02,
    BPQ_BLOCK_KIND_PUBLISH = 0x03
};
typedef enum dtn_bpq_extension_block_kind_t dtn_bpq_extension_block_kind_t;

%/**
% * BPQ Extension block matching rule. (More may be added later)
% *
% *     BPQ_MATCHING_RULE_EXACT
% */
%
enum dtn_bpq_extension_block_matching_rule_t {
    BPQ_MATCHING_RULE_EXACT = 0x00
};
typedef enum dtn_bpq_extension_block_matching_rule_t dtn_bpq_extension_block_matching_rule_t;

%/**
% * Extension block.
% */
struct dtn_extension_block_data_t {
    u_int data_len;
    char *data_val;
};

struct dtn_extension_block_t {
	u_int type;
	u_int flags;
        struct dtn_extension_block_data_t data;
};
typedef struct dtn_extension_block_t dtn_extension_block_t;


struct dtn_bpq_ext_block_original_id_t {
    dtn_timestamp_t creation_ts;
    u_int source_len;
    dtn_endpoint_id_t source;
};
struct dtn_bpq_ext_block_query_t {
    u_int query_len;
    char* query_val;
};
struct dtn_bpq_ext_block_fragments_t {
    u_int num_frag_returned;
    u_int *frag_offsets;
    u_int *frag_lenghts;
};


struct dtn_bpq_extension_block_data_t {
    u_int kind;
    u_int matching_rule;
    struct dtn_bpq_ext_block_original_id_t original_id;
    struct dtn_bpq_ext_block_query_t query;
    struct dtn_bpq_ext_block_fragments_t fragments;
};
typedef struct dtn_bpq_extension_block_data_t dtn_bpq_extension_block_data_t;

%
%/**
% * A Sequence ID is a vector of (EID, counter) values in the following
% * text format:
% *
% *    < (EID1 counter1) (EID2 counter2) ... >
% */
struct dtn_sequence_id_t {
    opaque data<DTN_MAX_BLOCK_LEN>;
};

%/**
% * Extended Class of Service (ECOS) flags bit definitions.
% *
% *     ECOS_FLAG_CRITICAL         - critical - send on every logical path
% *     ECOS_FLAG_STREAMING        - streaming - send on best efforts without retransmission
% *     ECOS_FLAG_FLOW_LABEL       - indicates flow label exists after the ordinal byte
% *     ECOS_FLAG_RELIABLE         - reliable - send on convergence layer that detects data loss and retransmits
% *
% * Use these bit definitions OR-ed together to set the ecos_flags parameter.
% */
%
enum dtn_ecos_flags_bits_t {
    ECOS_FLAG_CRITICAL    = 0x01,
    ECOS_FLAG_STREAMING   = 0x02,
    ECOS_FLAG_FLOW_LABEL  = 0x04,
    ECOS_FLAG_RELIABLE    = 0x08
};
typedef enum dtn_ecos_flags_bits_t dtn_ecos_flags_bits_t;

%
%/**
% * Bundle metadata. The delivery_regid is ignored when sending
% * bundles, but is filled in by the daemon with the registration
% * id where the bundle was received.
% */
struct dtn_bundle_spec_t {
    dtn_endpoint_id_t		source;
    dtn_endpoint_id_t		dest;
    dtn_endpoint_id_t		replyto;
    dtn_bundle_priority_t	priority;
    int				        dopts;
    dtn_timeval_t		    expiration;
    dtn_timestamp_t		    creation_ts;
    dtn_reg_id_t		    delivery_regid;
    dtn_sequence_id_t       sequence_id;
    dtn_sequence_id_t       obsoletes_id;
    bool                    ecos_enabled;
    u_int                   ecos_flags;
    u_int                   ecos_ordinal;
    u_int                   ecos_flow_label;
    u_int                   bp_version; 
    dtn_extension_block_t   blocks<DTN_MAX_BLOCKS>;
    dtn_extension_block_t   metadata<DTN_MAX_BLOCKS>;
};

%
%/**
% * Type definition for a unique bundle identifier. Returned from dtn_send
% * after the daemon has assigned the creation_secs and creation_subsecs,
% * in which case orig_length and frag_offset are always zero, and also in
% * status report data in which case they may be set if the bundle is
% * fragmented.
% */
struct dtn_bundle_id_t {
    dtn_endpoint_id_t   source;
    dtn_timestamp_t     creation_ts;
    u_int               frag_offset;
    u_int               orig_length;
};

%/**
% * Bundle Status Report "Reason Code" flags
% */
enum dtn_status_report_reason_t {
    REASON_NO_ADDTL_INFO	      = 0x00,
    REASON_LIFETIME_EXPIRED	      = 0x01,
    REASON_FORWARDED_UNIDIR_LINK      = 0x02,
    REASON_TRANSMISSION_CANCELLED     = 0x03,
    REASON_DEPLETED_STORAGE	      = 0x04,
    REASON_ENDPOINT_ID_UNINTELLIGIBLE = 0x05,
    REASON_NO_ROUTE_TO_DEST	      = 0x06,
    REASON_NO_TIMELY_CONTACT	      = 0x07,
    REASON_BLOCK_UNINTELLIGIBLE	      = 0x08
};

%/**
% * Bundle Status Report status flags that indicate which timestamps in
% * the status report structure are valid.
% */
enum dtn_status_report_flags_t {
    STATUS_RECEIVED		= 0x01,
    STATUS_CUSTODY_ACCEPTED	= 0x02,
    STATUS_FORWARDED		= 0x04,
    STATUS_DELIVERED		= 0x08,
    STATUS_DELETED		= 0x10,
    STATUS_ACKED_BY_APP		= 0x20
};

%
%/**
% * Type definition for a bundle status report.
% */
struct dtn_bundle_status_report_t {
    dtn_bundle_id_t 		bundle_id;
    dtn_status_report_reason_t 	reason;
    dtn_status_report_flags_t 	flags;
    dtn_timestamp_t		receipt_ts;
    dtn_timestamp_t 		custody_ts;
    dtn_timestamp_t 		forwarding_ts;
    dtn_timestamp_t 		delivery_ts;
    dtn_timestamp_t 		deletion_ts;
    dtn_timestamp_t 		ack_by_app_ts;
};

%
%/**
% * The payload of a bundle can be sent or received either in a file,
% * in which case the payload structure contains the filename, or in
% * memory where the struct contains the data in-band, in the 'buf'
% * field.
% *
% * When sending a bundle, if the location specifies that the payload
% * is in a temp file, then the daemon assumes ownership of the file
% * and should have sufficient permissions to move or rename it.
% *
% * When receiving a bundle that is a status report, then the
% * status_report pointer will be non-NULL and will point to a
% * dtn_bundle_status_report_t structure which contains the parsed fields
% * of the status report.
% *
% *     DTN_PAYLOAD_MEM                       - payload contents in memory
% *     DTN_PAYLOAD_FILE                      - payload contents in file
% *     DTN_PAYLOAD_TEMP_FILE                 - in file, assume ownership (send only)
% *     DTN_PAYLOAD_VARIABLE                  - payload contents in memory if up to the max allowed else in file
% *     DTN_PAYLOAD_RELEASED_DB_FILE          - payload contents as original database file released to the app
% *     DTN_PAYLOAD_VARIABLE_RELEASED_DB_FILE - payload contents in memory if up to the max allowed else as
% *                                             original database file released to the app
% */
enum dtn_bundle_payload_location_t {
    DTN_PAYLOAD_FILE,
    DTN_PAYLOAD_MEM,
    DTN_PAYLOAD_TEMP_FILE,
    DTN_PAYLOAD_VARIABLE,
    DTN_PAYLOAD_RELEASED_DB_FILE,
    DTN_PAYLOAD_VARIABLE_RELEASED_DB_FILE
};

struct dtn_bundle_payload_t
{
    dtn_bundle_payload_location_t location;
    opaque                        filename<DTN_MAX_PATH_LEN>;
    opaque                        buf<DTN_MAX_BUNDLE_MEM>;
    dtn_bundle_status_report_t*   status_report;
    uint64_t                      size_of_payload;
};
