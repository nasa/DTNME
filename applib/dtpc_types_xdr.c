/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "dtpc_types.h"
/*
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
*/

/**********************************
 * This file defines the types used in the DTPC client API. The structures are
 * autogenerated using rpcgen, as are the marshalling and unmarshalling
 * XDR routines.
 */

#include <limits.h>

#ifndef ARG_MAX
#define ARG_MAX _POSIX_ARG_MAX
#endif

/**********************************
 * Constants.
 * (Note that we use #defines to get the comments as well)
 */
#define DTPC_MAX_ENDPOINT_ID 256 /* max endpoint_id size (bytes) */
#define DTPC_MAX_PATH_LEN PATH_MAX /* max path length */
#define DTPC_MAX_DATA_ITEM_MEM 50000 /* biggest in-memory bundle is ~50K*/

/**
 * Specification of a dtpc endpoint id, i.e. a URI, implemented as a
 * fixed-length char buffer. Note that for efficiency reasons, this
 * fixed length is relatively small (256 bytes). 
 * 
 * The alternative is to use the string XDR type but then all endpoint
 * ids would require malloc / free which is more prone to leaks / bugs.
 */

bool_t
xdr_dtpc_endpoint_id_t (XDR *xdrs, dtpc_endpoint_id_t *objp)
{
	register int32_t *buf;

	int i;
	 if (!xdr_opaque (xdrs, objp->uri, DTPC_MAX_ENDPOINT_ID))
		 return FALSE;
	return TRUE;
}

/**
 * Transmission Profile ID
 */

bool_t
xdr_dtpc_profile_id_t (XDR *xdrs, dtpc_profile_id_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * Topic ID 
 */

bool_t
xdr_dtpc_topic_id_t (XDR *xdrs, dtpc_topic_id_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * DTPC Topic Registration state.
 */

bool_t
xdr_dtpc_reg_info_t (XDR *xdrs, dtpc_reg_info_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtpc_topic_id_t (xdrs, &objp->topic_id))
		 return FALSE;
	 if (!xdr_bool (xdrs, &objp->has_elision_func))
		 return FALSE;
	return TRUE;
}

/**
 * Timeout in seconds
 */

bool_t
xdr_dtpc_timeval_t (XDR *xdrs, dtpc_timeval_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * The dtpc_recv method processes both the receiving Application
 * Data Items (ADI) and the Elision Funcion callback. The first element
 * read is the dtpc_recv_type_t which identifies which is currently
 * being returned so that it can be processed accordingly. 
 * 
 * If the API Server is returning an ADI then the first element will be 
 * a value of DTPC_RECV_TYPE_DATA_ITEM followed by the Source Endpoint ID 
 * (dtpc_endpoint_id_t) and the ADI (dtpc_data_item_spec_t).
 *
 * If the API Server is initiating an elision function invocation then
 * the first element will be a value of DTPC_RECV_TYPE_ELISION_FUNC 
 * followed by the Destination Enpoint ID (dtpc_endpoint_id_t), 
 * the number of ADIs being supplied (dtpc_num_data_items_t) and then 
 * the actual ADIs (dtpc_data_item_spec_t) which can be read in a loop.
 */

bool_t
xdr_dtpc_recv_type_t (XDR *xdrs, dtpc_recv_type_t *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

/**
 * A single application data item can be sent or received only via
 * memory where the struct contains the data in-band, in the 'buf'
 * field.
 *
 * If the need arises, passing by file can be implemented similar
 * to the payload in dtn_types.x.
 **/

bool_t
xdr_dtpc_data_item_t (XDR *xdrs, dtpc_data_item_t *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->buf.buf_val, (u_int *) &objp->buf.buf_len, ~0))
		 return FALSE;
	return TRUE;
}

/**
 * This list structure is used internally to pass a list of ADIs
 * between the server and API client to service an elision function.
 * The elements are passed individually to the elision function and
 * only the data_items array is modifiable.
 **/

bool_t
xdr_dtpc_data_item_list_t (XDR *xdrs, dtpc_data_item_list_t *objp)
{
	register int32_t *buf;

	 if (!xdr_dtpc_endpoint_id_t (xdrs, &objp->dest_eid))
		 return FALSE;
	 if (!xdr_dtpc_profile_id_t (xdrs, &objp->profile_id))
		 return FALSE;
	 if (!xdr_dtpc_topic_id_t (xdrs, &objp->topic_id))
		 return FALSE;
	 if (!xdr_array (xdrs, (char **)&objp->data_items.data_items_val, (u_int *) &objp->data_items.data_items_len, ~0,
		sizeof (dtpc_data_item_t), (xdrproc_t) xdr_dtpc_data_item_t))
		 return FALSE;
	return TRUE;
}

/**
 * The number of data items being passed for an elision function
 * invocation or response
 **/

bool_t
xdr_dtpc_num_data_items_t (XDR *xdrs, dtpc_num_data_items_t *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * The application response to an elision function invocation back to
 * the API Server consists of an indication of whether any modification
 * was made to the list of ADIs (dtpc_elision_func_modified_t) and if 
 * a modification was made then the number of ADIs (dtpc_num_data_items_t) 
 * followed by the actual ADIs () are sent.
 */

bool_t
xdr_dtpc_elision_func_modified_t (XDR *xdrs, dtpc_elision_func_modified_t *objp)
{
	register int32_t *buf;

	 if (!xdr_bool (xdrs, objp))
		 return FALSE;
	return TRUE;
}

/**
 * Definition of the pointer to the elision function which must be passed
 * in to the dtpc_recv call in order to get elision callbacks. If null is
 * passed in then any elision calls will return as nothing modified.
 *
 * > You must manually uncomment the line below in the dtpc_types.h file
 **/
//typedef void (*ptr_elision_func_t)(dtpc_data_item_list_t* list, bool_t* modified);

