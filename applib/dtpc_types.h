/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _DTPC_TYPES_H_RPCGEN
#define _DTPC_TYPES_H_RPCGEN

#include <rpc/rpc.h>


#ifdef __cplusplus
extern "C" {
#endif

/*
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
*/

/**********************************
 * This file defines the types used in the DTPC client API. The structures are
 * autogenerated using rpcgen, as are the marshalling and unmarshalling
 * XDR routines.
 */

#include <limits.h>

#ifndef ARG_MAX
#define ARG_MAX _POSIX_ARG_MAX
#endif

/**********************************
 * Constants.
 * (Note that we use #defines to get the comments as well)
 */
#define DTPC_MAX_ENDPOINT_ID 256 /* max endpoint_id size (bytes) */
#define DTPC_MAX_PATH_LEN PATH_MAX /* max path length */
#define DTPC_MAX_DATA_ITEM_MEM 1048576 /* biggest in-memory bundle is 1MB*/

/**
 * Specification of a dtpc endpoint id, i.e. a URI, implemented as a
 * fixed-length char buffer. Note that for efficiency reasons, this
 * fixed length is relatively small (256 bytes). 
 * 
 * The alternative is to use the string XDR type but then all endpoint
 * ids would require malloc / free which is more prone to leaks / bugs.
 */

struct dtpc_endpoint_id_t {
	char uri[DTPC_MAX_ENDPOINT_ID];
};
typedef struct dtpc_endpoint_id_t dtpc_endpoint_id_t;

/**
 * Transmission Profile ID
 */

typedef u_int dtpc_profile_id_t;

/**
 * Topic ID 
 */

typedef u_int dtpc_topic_id_t;

/**
 * DTPC Topic Registration state.
 */

struct dtpc_reg_info_t {
	dtpc_topic_id_t topic_id;
	bool_t has_elision_func;
};
typedef struct dtpc_reg_info_t dtpc_reg_info_t;

/**
 * Timeout in seconds
 */

typedef u_int dtpc_timeval_t;

/**
 * The dtpc_recv method processes both the receiving Application
 * Data Items (ADI) and the Elision Funcion callback. The first element
 * read is the dtpc_recv_type_t which identifies which is currently
 * being returned so that it can be processed accordingly. 
 * 
 * If the API Server is returning an ADI then the first element will be 
 * a value of DTPC_RECV_TYPE_DATA_ITEM followed by the Source Endpoint ID 
 * (dtpc_endpoint_id_t) and the ADI (dtpc_data_item_spec_t).
 *
 * If the API Server is initiating an elision function invocation then
 * the first element will be a value of DTPC_RECV_TYPE_ELISION_FUNC 
 * followed by the Destination Enpoint ID (dtpc_endpoint_id_t), 
 * the number of ADIs being supplied (dtpc_num_data_items_t) and then 
 * the actual ADIs (dtpc_data_item_spec_t) which can be read in a loop.
 */

enum dtpc_recv_type_t {
	DTPC_RECV_TYPE_INVALID = 0,
	DTPC_RECV_TYPE_DATA_ITEM = 1,
	DTPC_RECV_TYPE_ELISION_FUNC = 2,
};
typedef enum dtpc_recv_type_t dtpc_recv_type_t;


/**
 * A single application data item can be sent or received only via
 * memory where the struct contains the data in-band, in the 'buf'
 * field.
 *
 * If the need arises, passing by file can be implemented similar
 * to the payload in dtn_types.x.
 **/

struct dtpc_data_item_t {
	struct {
		u_int buf_len;
		char *buf_val;
	} buf;
};
typedef struct dtpc_data_item_t dtpc_data_item_t;

/**
 * This list structure is used internally to pass a list of ADIs
 * between the server and API client to service an elision function.
 * The elements are passed individually to the elision function and
 * only the data_items array is modifiable.
 **/

struct dtpc_data_item_list_t {
	dtpc_endpoint_id_t dest_eid;
	dtpc_profile_id_t profile_id;
	dtpc_topic_id_t topic_id;
	struct {
		u_int data_items_len;
		dtpc_data_item_t *data_items_val;
	} data_items;
};
typedef struct dtpc_data_item_list_t dtpc_data_item_list_t;

/**
 * The number of data items being passed for an elision function
 * invocation or response
 **/

typedef u_int dtpc_num_data_items_t;

/**
 * The application response to an elision function invocation back to
 * the API Server consists of an indication of whether any modification
 * was made to the list of ADIs (dtpc_elision_func_modified_t) and if 
 * a modification was made then the number of ADIs (dtpc_num_data_items_t) 
 * followed by the actual ADIs () are sent.
 */

typedef bool_t dtpc_elision_func_modified_t;

/**
 * Definition of the pointer to the elision function which must be passed
 * in to the dtpc_recv call in order to get elision callbacks. If null is
 * passed in then any elision calls will return as nothing modified.
 *
 * > You must manually uncomment the line below in the dtpc_types.h file
 **/
//typedef void (*ptr_elision_func_t)(dtpc_data_item_list_t* list, bool_t* modified);


/* the xdr functions */

#if defined(__STDC__) || defined(__cplusplus)
extern  bool_t xdr_dtpc_endpoint_id_t (XDR *, dtpc_endpoint_id_t*);
extern  bool_t xdr_dtpc_profile_id_t (XDR *, dtpc_profile_id_t*);
extern  bool_t xdr_dtpc_topic_id_t (XDR *, dtpc_topic_id_t*);
extern  bool_t xdr_dtpc_reg_info_t (XDR *, dtpc_reg_info_t*);
extern  bool_t xdr_dtpc_timeval_t (XDR *, dtpc_timeval_t*);
extern  bool_t xdr_dtpc_recv_type_t (XDR *, dtpc_recv_type_t*);
extern  bool_t xdr_dtpc_recv_type_t (XDR *, dtpc_recv_type_t*);
extern  bool_t xdr_dtpc_data_item_t (XDR *, dtpc_data_item_t*);
extern  bool_t xdr_dtpc_data_item_list_t (XDR *, dtpc_data_item_list_t*);
extern  bool_t xdr_dtpc_num_data_items_t (XDR *, dtpc_num_data_items_t*);
extern  bool_t xdr_dtpc_elision_func_modified_t (XDR *, dtpc_elision_func_modified_t*);

#else /* K&R C */
extern bool_t xdr_dtpc_endpoint_id_t ();
extern bool_t xdr_dtpc_profile_id_t ();
extern bool_t xdr_dtpc_topic_id_t ();
extern bool_t xdr_dtpc_reg_info_t ();
extern bool_t xdr_dtpc_timeval_t ();
extern bool_t xdr_dtpc_recv_type_t ();
extern bool_t xdr_dtpc_recv_type_t ();
extern bool_t xdr_dtpc_data_item_t ();
extern bool_t xdr_dtpc_data_item_list_t ();
extern bool_t xdr_dtpc_num_data_items_t ();
extern bool_t xdr_dtpc_elision_func_modified_t ();

#endif /* K&R C */

#ifdef __cplusplus
}
#endif

#endif /* !_DTPC_TYPES_H_RPCGEN */
