// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#include <oasys-config.h>
#if defined(XERCES_C_ENABLED) && defined(EXTERNAL_DS_ENABLED)
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DS.h"

namespace dsmessage
{
  // storeType
  // 

  storeType::
  storeType (_xsd_storeType v)
  : ::xml_schema::string (_xsd_storeType_literals_[v])
  {
  }

  storeType::
  storeType (const ::xml_schema::string& _xsd_storeType)
  : ::xml_schema::string (_xsd_storeType)
  {
  }

  storeType::
  storeType (const storeType& v,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  storeType& storeType::
  operator= (_xsd_storeType v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_storeType_literals_[v]);

    return *this;
  }


  // tableInfoType
  // 

  const tableInfoType::table::type& tableInfoType::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  tableInfoType::table::type& tableInfoType::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void tableInfoType::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void tableInfoType::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }


  // fieldType
  // 

  fieldType::
  fieldType (_xsd_fieldType v)
  : ::xml_schema::string (_xsd_fieldType_literals_[v])
  {
  }

  fieldType::
  fieldType (const ::xml_schema::string& _xsd_fieldType)
  : ::xml_schema::string (_xsd_fieldType)
  {
  }

  fieldType::
  fieldType (const fieldType& v,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  fieldType& fieldType::
  operator= (_xsd_fieldType v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_fieldType_literals_[v]);

    return *this;
  }


  // fieldInfoType
  // 

  const fieldInfoType::field::type& fieldInfoType::
  field () const
  {
    return this->_xsd_field_.get ();
  }

  fieldInfoType::field::type& fieldInfoType::
  field ()
  {
    return this->_xsd_field_.get ();
  }

  void fieldInfoType::
  field (const field::type& field)
  {
    this->_xsd_field_.set (field);
  }

  void fieldInfoType::
  field (::std::auto_ptr< field::type > field)
  {
    this->_xsd_field_.set (field);
  }

  const fieldInfoType::type::type_& fieldInfoType::
  type () const
  {
    return this->_xsd_type_.get ();
  }

  fieldInfoType::type::type_& fieldInfoType::
  type ()
  {
    return this->_xsd_type_.get ();
  }

  void fieldInfoType::
  type (const type::type_& type)
  {
    this->_xsd_type_.set (type);
  }

  void fieldInfoType::
  type (::std::auto_ptr< type::type_ > type)
  {
    this->_xsd_type_.set (type);
  }


  // fieldNameValue
  // 

  const fieldNameValue::value::type& fieldNameValue::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  fieldNameValue::value::type& fieldNameValue::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void fieldNameValue::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void fieldNameValue::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const fieldNameValue::field::type& fieldNameValue::
  field () const
  {
    return this->_xsd_field_.get ();
  }

  fieldNameValue::field::type& fieldNameValue::
  field ()
  {
    return this->_xsd_field_.get ();
  }

  void fieldNameValue::
  field (const field::type& field)
  {
    this->_xsd_field_.set (field);
  }

  void fieldNameValue::
  field (::std::auto_ptr< field::type > field)
  {
    this->_xsd_field_.set (field);
  }


  // fieldName
  // 

  const fieldName::field::type& fieldName::
  field () const
  {
    return this->_xsd_field_.get ();
  }

  fieldName::field::type& fieldName::
  field ()
  {
    return this->_xsd_field_.get ();
  }

  void fieldName::
  field (const field::type& field)
  {
    this->_xsd_field_.set (field);
  }

  void fieldName::
  field (::std::auto_ptr< field::type > field)
  {
    this->_xsd_field_.set (field);
  }


  // languageName
  // 

  const languageName::language::type& languageName::
  language () const
  {
    return this->_xsd_language_.get ();
  }

  languageName::language::type& languageName::
  language ()
  {
    return this->_xsd_language_.get ();
  }

  void languageName::
  language (const language::type& language)
  {
    this->_xsd_language_.set (language);
  }

  void languageName::
  language (::std::auto_ptr< language::type > language)
  {
    this->_xsd_language_.set (language);
  }


  // ds_caps_request_type
  // 


  // ds_caps_reply_type
  // 

  const ds_caps_reply_type::language::container& ds_caps_reply_type::
  language () const
  {
    return this->_xsd_language_;
  }

  ds_caps_reply_type::language::container& ds_caps_reply_type::
  language ()
  {
    return this->_xsd_language_;
  }

  void ds_caps_reply_type::
  language (const language::container& language)
  {
    this->_xsd_language_ = language;
  }

  const ds_caps_reply_type::storetype::type& ds_caps_reply_type::
  storetype () const
  {
    return this->_xsd_storetype_.get ();
  }

  ds_caps_reply_type::storetype::type& ds_caps_reply_type::
  storetype ()
  {
    return this->_xsd_storetype_.get ();
  }

  void ds_caps_reply_type::
  storetype (const storetype::type& storetype)
  {
    this->_xsd_storetype_.set (storetype);
  }

  void ds_caps_reply_type::
  storetype (::std::auto_ptr< storetype::type > storetype)
  {
    this->_xsd_storetype_.set (storetype);
  }

  const ds_caps_reply_type::supports_trigger::type& ds_caps_reply_type::
  supports_trigger () const
  {
    return this->_xsd_supports_trigger_.get ();
  }

  ds_caps_reply_type::supports_trigger::type& ds_caps_reply_type::
  supports_trigger ()
  {
    return this->_xsd_supports_trigger_.get ();
  }

  void ds_caps_reply_type::
  supports_trigger (const supports_trigger::type& supports_trigger)
  {
    this->_xsd_supports_trigger_.set (supports_trigger);
  }


  // ds_create_request_type
  // 

  const ds_create_request_type::password::container& ds_create_request_type::
  password () const
  {
    return this->_xsd_password_;
  }

  ds_create_request_type::password::container& ds_create_request_type::
  password ()
  {
    return this->_xsd_password_;
  }

  void ds_create_request_type::
  password (const password::type& password)
  {
    this->_xsd_password_.set (password);
  }

  void ds_create_request_type::
  password (const password::container& password)
  {
    this->_xsd_password_ = password;
  }

  void ds_create_request_type::
  password (::std::auto_ptr< password::type > password)
  {
    this->_xsd_password_.set (password);
  }

  const ds_create_request_type::ds::type& ds_create_request_type::
  ds () const
  {
    return this->_xsd_ds_.get ();
  }

  ds_create_request_type::ds::type& ds_create_request_type::
  ds ()
  {
    return this->_xsd_ds_.get ();
  }

  void ds_create_request_type::
  ds (const ds::type& ds)
  {
    this->_xsd_ds_.set (ds);
  }

  void ds_create_request_type::
  ds (::std::auto_ptr< ds::type > ds)
  {
    this->_xsd_ds_.set (ds);
  }

  const ds_create_request_type::clear::container& ds_create_request_type::
  clear () const
  {
    return this->_xsd_clear_;
  }

  ds_create_request_type::clear::container& ds_create_request_type::
  clear ()
  {
    return this->_xsd_clear_;
  }

  void ds_create_request_type::
  clear (const clear::type& clear)
  {
    this->_xsd_clear_.set (clear);
  }

  void ds_create_request_type::
  clear (const clear::container& clear)
  {
    this->_xsd_clear_ = clear;
  }

  const ds_create_request_type::quota::container& ds_create_request_type::
  quota () const
  {
    return this->_xsd_quota_;
  }

  ds_create_request_type::quota::container& ds_create_request_type::
  quota ()
  {
    return this->_xsd_quota_;
  }

  void ds_create_request_type::
  quota (const quota::type& quota)
  {
    this->_xsd_quota_.set (quota);
  }

  void ds_create_request_type::
  quota (const quota::container& quota)
  {
    this->_xsd_quota_ = quota;
  }

  const ds_create_request_type::user::container& ds_create_request_type::
  user () const
  {
    return this->_xsd_user_;
  }

  ds_create_request_type::user::container& ds_create_request_type::
  user ()
  {
    return this->_xsd_user_;
  }

  void ds_create_request_type::
  user (const user::type& user)
  {
    this->_xsd_user_.set (user);
  }

  void ds_create_request_type::
  user (const user::container& user)
  {
    this->_xsd_user_ = user;
  }

  void ds_create_request_type::
  user (::std::auto_ptr< user::type > user)
  {
    this->_xsd_user_.set (user);
  }


  // ds_create_reply_type
  // 


  // ds_del_request_type
  // 

  const ds_del_request_type::password::container& ds_del_request_type::
  password () const
  {
    return this->_xsd_password_;
  }

  ds_del_request_type::password::container& ds_del_request_type::
  password ()
  {
    return this->_xsd_password_;
  }

  void ds_del_request_type::
  password (const password::type& password)
  {
    this->_xsd_password_.set (password);
  }

  void ds_del_request_type::
  password (const password::container& password)
  {
    this->_xsd_password_ = password;
  }

  void ds_del_request_type::
  password (::std::auto_ptr< password::type > password)
  {
    this->_xsd_password_.set (password);
  }

  const ds_del_request_type::ds::type& ds_del_request_type::
  ds () const
  {
    return this->_xsd_ds_.get ();
  }

  ds_del_request_type::ds::type& ds_del_request_type::
  ds ()
  {
    return this->_xsd_ds_.get ();
  }

  void ds_del_request_type::
  ds (const ds::type& ds)
  {
    this->_xsd_ds_.set (ds);
  }

  void ds_del_request_type::
  ds (::std::auto_ptr< ds::type > ds)
  {
    this->_xsd_ds_.set (ds);
  }

  const ds_del_request_type::user::container& ds_del_request_type::
  user () const
  {
    return this->_xsd_user_;
  }

  ds_del_request_type::user::container& ds_del_request_type::
  user ()
  {
    return this->_xsd_user_;
  }

  void ds_del_request_type::
  user (const user::type& user)
  {
    this->_xsd_user_.set (user);
  }

  void ds_del_request_type::
  user (const user::container& user)
  {
    this->_xsd_user_ = user;
  }

  void ds_del_request_type::
  user (::std::auto_ptr< user::type > user)
  {
    this->_xsd_user_.set (user);
  }


  // ds_del_reply_type
  // 


  // ds_open_request_type
  // 

  const ds_open_request_type::password::container& ds_open_request_type::
  password () const
  {
    return this->_xsd_password_;
  }

  ds_open_request_type::password::container& ds_open_request_type::
  password ()
  {
    return this->_xsd_password_;
  }

  void ds_open_request_type::
  password (const password::type& password)
  {
    this->_xsd_password_.set (password);
  }

  void ds_open_request_type::
  password (const password::container& password)
  {
    this->_xsd_password_ = password;
  }

  void ds_open_request_type::
  password (::std::auto_ptr< password::type > password)
  {
    this->_xsd_password_.set (password);
  }

  const ds_open_request_type::ds::type& ds_open_request_type::
  ds () const
  {
    return this->_xsd_ds_.get ();
  }

  ds_open_request_type::ds::type& ds_open_request_type::
  ds ()
  {
    return this->_xsd_ds_.get ();
  }

  void ds_open_request_type::
  ds (const ds::type& ds)
  {
    this->_xsd_ds_.set (ds);
  }

  void ds_open_request_type::
  ds (::std::auto_ptr< ds::type > ds)
  {
    this->_xsd_ds_.set (ds);
  }

  const ds_open_request_type::lease::container& ds_open_request_type::
  lease () const
  {
    return this->_xsd_lease_;
  }

  ds_open_request_type::lease::container& ds_open_request_type::
  lease ()
  {
    return this->_xsd_lease_;
  }

  void ds_open_request_type::
  lease (const lease::type& lease)
  {
    this->_xsd_lease_.set (lease);
  }

  void ds_open_request_type::
  lease (const lease::container& lease)
  {
    this->_xsd_lease_ = lease;
  }

  const ds_open_request_type::user::container& ds_open_request_type::
  user () const
  {
    return this->_xsd_user_;
  }

  ds_open_request_type::user::container& ds_open_request_type::
  user ()
  {
    return this->_xsd_user_;
  }

  void ds_open_request_type::
  user (const user::type& user)
  {
    this->_xsd_user_.set (user);
  }

  void ds_open_request_type::
  user (const user::container& user)
  {
    this->_xsd_user_ = user;
  }

  void ds_open_request_type::
  user (::std::auto_ptr< user::type > user)
  {
    this->_xsd_user_.set (user);
  }


  // ds_open_reply_type
  // 

  const ds_open_reply_type::handle::container& ds_open_reply_type::
  handle () const
  {
    return this->_xsd_handle_;
  }

  ds_open_reply_type::handle::container& ds_open_reply_type::
  handle ()
  {
    return this->_xsd_handle_;
  }

  void ds_open_reply_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void ds_open_reply_type::
  handle (const handle::container& handle)
  {
    this->_xsd_handle_ = handle;
  }

  void ds_open_reply_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }


  // ds_stat_request_type
  // 

  const ds_stat_request_type::handle::type& ds_stat_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  ds_stat_request_type::handle::type& ds_stat_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void ds_stat_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void ds_stat_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }


  // ds_stat_reply_type
  // 

  const ds_stat_reply_type::table::container& ds_stat_reply_type::
  table () const
  {
    return this->_xsd_table_;
  }

  ds_stat_reply_type::table::container& ds_stat_reply_type::
  table ()
  {
    return this->_xsd_table_;
  }

  void ds_stat_reply_type::
  table (const table::container& table)
  {
    this->_xsd_table_ = table;
  }


  // ds_close_request_type
  // 

  const ds_close_request_type::handle::type& ds_close_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  ds_close_request_type::handle::type& ds_close_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void ds_close_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void ds_close_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }


  // ds_close_reply_type
  // 


  // table_create_request_type
  // 

  const table_create_request_type::field::container& table_create_request_type::
  field () const
  {
    return this->_xsd_field_;
  }

  table_create_request_type::field::container& table_create_request_type::
  field ()
  {
    return this->_xsd_field_;
  }

  void table_create_request_type::
  field (const field::container& field)
  {
    this->_xsd_field_ = field;
  }

  const table_create_request_type::handle::type& table_create_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  table_create_request_type::handle::type& table_create_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void table_create_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void table_create_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const table_create_request_type::table::type& table_create_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  table_create_request_type::table::type& table_create_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void table_create_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void table_create_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const table_create_request_type::key::type& table_create_request_type::
  key () const
  {
    return this->_xsd_key_.get ();
  }

  table_create_request_type::key::type& table_create_request_type::
  key ()
  {
    return this->_xsd_key_.get ();
  }

  void table_create_request_type::
  key (const key::type& key)
  {
    this->_xsd_key_.set (key);
  }

  void table_create_request_type::
  key (::std::auto_ptr< key::type > key)
  {
    this->_xsd_key_.set (key);
  }

  const table_create_request_type::keytype::type& table_create_request_type::
  keytype () const
  {
    return this->_xsd_keytype_.get ();
  }

  table_create_request_type::keytype::type& table_create_request_type::
  keytype ()
  {
    return this->_xsd_keytype_.get ();
  }

  void table_create_request_type::
  keytype (const keytype::type& keytype)
  {
    this->_xsd_keytype_.set (keytype);
  }

  void table_create_request_type::
  keytype (::std::auto_ptr< keytype::type > keytype)
  {
    this->_xsd_keytype_.set (keytype);
  }


  // table_create_reply_type
  // 


  // table_del_request_type
  // 

  const table_del_request_type::handle::type& table_del_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  table_del_request_type::handle::type& table_del_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void table_del_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void table_del_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const table_del_request_type::table::type& table_del_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  table_del_request_type::table::type& table_del_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void table_del_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void table_del_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }


  // table_del_reply_type
  // 


  // table_stat_request_type
  // 

  const table_stat_request_type::handle::type& table_stat_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  table_stat_request_type::handle::type& table_stat_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void table_stat_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void table_stat_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const table_stat_request_type::table::type& table_stat_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  table_stat_request_type::table::type& table_stat_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void table_stat_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void table_stat_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }


  // table_stat_reply_type
  // 

  const table_stat_reply_type::field::container& table_stat_reply_type::
  field () const
  {
    return this->_xsd_field_;
  }

  table_stat_reply_type::field::container& table_stat_reply_type::
  field ()
  {
    return this->_xsd_field_;
  }

  void table_stat_reply_type::
  field (const field::container& field)
  {
    this->_xsd_field_ = field;
  }

  const table_stat_reply_type::keyname::type& table_stat_reply_type::
  keyname () const
  {
    return this->_xsd_keyname_.get ();
  }

  table_stat_reply_type::keyname::type& table_stat_reply_type::
  keyname ()
  {
    return this->_xsd_keyname_.get ();
  }

  void table_stat_reply_type::
  keyname (const keyname::type& keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  void table_stat_reply_type::
  keyname (::std::auto_ptr< keyname::type > keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  const table_stat_reply_type::keytype::type& table_stat_reply_type::
  keytype () const
  {
    return this->_xsd_keytype_.get ();
  }

  table_stat_reply_type::keytype::type& table_stat_reply_type::
  keytype ()
  {
    return this->_xsd_keytype_.get ();
  }

  void table_stat_reply_type::
  keytype (const keytype::type& keytype)
  {
    this->_xsd_keytype_.set (keytype);
  }

  void table_stat_reply_type::
  keytype (::std::auto_ptr< keytype::type > keytype)
  {
    this->_xsd_keytype_.set (keytype);
  }

  const table_stat_reply_type::count::type& table_stat_reply_type::
  count () const
  {
    return this->_xsd_count_.get ();
  }

  table_stat_reply_type::count::type& table_stat_reply_type::
  count ()
  {
    return this->_xsd_count_.get ();
  }

  void table_stat_reply_type::
  count (const count::type& count)
  {
    this->_xsd_count_.set (count);
  }


  // table_keys_request_type
  // 

  const table_keys_request_type::handle::type& table_keys_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  table_keys_request_type::handle::type& table_keys_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void table_keys_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void table_keys_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const table_keys_request_type::table::type& table_keys_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  table_keys_request_type::table::type& table_keys_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void table_keys_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void table_keys_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const table_keys_request_type::keyname::type& table_keys_request_type::
  keyname () const
  {
    return this->_xsd_keyname_.get ();
  }

  table_keys_request_type::keyname::type& table_keys_request_type::
  keyname ()
  {
    return this->_xsd_keyname_.get ();
  }

  void table_keys_request_type::
  keyname (const keyname::type& keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  void table_keys_request_type::
  keyname (::std::auto_ptr< keyname::type > keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }


  // table_keys_reply_type
  // 

  const table_keys_reply_type::key::container& table_keys_reply_type::
  key () const
  {
    return this->_xsd_key_;
  }

  table_keys_reply_type::key::container& table_keys_reply_type::
  key ()
  {
    return this->_xsd_key_;
  }

  void table_keys_reply_type::
  key (const key::container& key)
  {
    this->_xsd_key_ = key;
  }


  // put_request_type
  // 

  const put_request_type::key::type& put_request_type::
  key () const
  {
    return this->_xsd_key_.get ();
  }

  put_request_type::key::type& put_request_type::
  key ()
  {
    return this->_xsd_key_.get ();
  }

  void put_request_type::
  key (const key::type& key)
  {
    this->_xsd_key_.set (key);
  }

  void put_request_type::
  key (::std::auto_ptr< key::type > key)
  {
    this->_xsd_key_.set (key);
  }

  const put_request_type::set::container& put_request_type::
  set () const
  {
    return this->_xsd_set_;
  }

  put_request_type::set::container& put_request_type::
  set ()
  {
    return this->_xsd_set_;
  }

  void put_request_type::
  set (const set::container& set)
  {
    this->_xsd_set_ = set;
  }

  const put_request_type::handle::type& put_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  put_request_type::handle::type& put_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void put_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void put_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const put_request_type::table::type& put_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  put_request_type::table::type& put_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void put_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void put_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const put_request_type::keyname::type& put_request_type::
  keyname () const
  {
    return this->_xsd_keyname_.get ();
  }

  put_request_type::keyname::type& put_request_type::
  keyname ()
  {
    return this->_xsd_keyname_.get ();
  }

  void put_request_type::
  keyname (const keyname::type& keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  void put_request_type::
  keyname (::std::auto_ptr< keyname::type > keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }


  // put_reply_type
  // 


  // get_request_type
  // 

  const get_request_type::key::type& get_request_type::
  key () const
  {
    return this->_xsd_key_.get ();
  }

  get_request_type::key::type& get_request_type::
  key ()
  {
    return this->_xsd_key_.get ();
  }

  void get_request_type::
  key (const key::type& key)
  {
    this->_xsd_key_.set (key);
  }

  void get_request_type::
  key (::std::auto_ptr< key::type > key)
  {
    this->_xsd_key_.set (key);
  }

  const get_request_type::handle::type& get_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  get_request_type::handle::type& get_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void get_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void get_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const get_request_type::table::type& get_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  get_request_type::table::type& get_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void get_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void get_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const get_request_type::keyname::type& get_request_type::
  keyname () const
  {
    return this->_xsd_keyname_.get ();
  }

  get_request_type::keyname::type& get_request_type::
  keyname ()
  {
    return this->_xsd_keyname_.get ();
  }

  void get_request_type::
  keyname (const keyname::type& keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  void get_request_type::
  keyname (::std::auto_ptr< keyname::type > keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }


  // get_reply_type
  // 

  const get_reply_type::field::container& get_reply_type::
  field () const
  {
    return this->_xsd_field_;
  }

  get_reply_type::field::container& get_reply_type::
  field ()
  {
    return this->_xsd_field_;
  }

  void get_reply_type::
  field (const field::container& field)
  {
    this->_xsd_field_ = field;
  }


  // del_request_type
  // 

  const del_request_type::key::type& del_request_type::
  key () const
  {
    return this->_xsd_key_.get ();
  }

  del_request_type::key::type& del_request_type::
  key ()
  {
    return this->_xsd_key_.get ();
  }

  void del_request_type::
  key (const key::type& key)
  {
    this->_xsd_key_.set (key);
  }

  void del_request_type::
  key (::std::auto_ptr< key::type > key)
  {
    this->_xsd_key_.set (key);
  }

  const del_request_type::handle::type& del_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  del_request_type::handle::type& del_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void del_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void del_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const del_request_type::table::type& del_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  del_request_type::table::type& del_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void del_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void del_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const del_request_type::keyname::type& del_request_type::
  keyname () const
  {
    return this->_xsd_keyname_.get ();
  }

  del_request_type::keyname::type& del_request_type::
  keyname ()
  {
    return this->_xsd_keyname_.get ();
  }

  void del_request_type::
  keyname (const keyname::type& keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }

  void del_request_type::
  keyname (::std::auto_ptr< keyname::type > keyname)
  {
    this->_xsd_keyname_.set (keyname);
  }


  // del_reply_type
  // 


  // select_request_type
  // 

  const select_request_type::get::container& select_request_type::
  get () const
  {
    return this->_xsd_get_;
  }

  select_request_type::get::container& select_request_type::
  get ()
  {
    return this->_xsd_get_;
  }

  void select_request_type::
  get (const get::container& get)
  {
    this->_xsd_get_ = get;
  }

  const select_request_type::where::container& select_request_type::
  where () const
  {
    return this->_xsd_where_;
  }

  select_request_type::where::container& select_request_type::
  where ()
  {
    return this->_xsd_where_;
  }

  void select_request_type::
  where (const where::container& where)
  {
    this->_xsd_where_ = where;
  }

  const select_request_type::handle::type& select_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  select_request_type::handle::type& select_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void select_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void select_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const select_request_type::table::type& select_request_type::
  table () const
  {
    return this->_xsd_table_.get ();
  }

  select_request_type::table::type& select_request_type::
  table ()
  {
    return this->_xsd_table_.get ();
  }

  void select_request_type::
  table (const table::type& table)
  {
    this->_xsd_table_.set (table);
  }

  void select_request_type::
  table (::std::auto_ptr< table::type > table)
  {
    this->_xsd_table_.set (table);
  }

  const select_request_type::count::container& select_request_type::
  count () const
  {
    return this->_xsd_count_;
  }

  select_request_type::count::container& select_request_type::
  count ()
  {
    return this->_xsd_count_;
  }

  void select_request_type::
  count (const count::type& count)
  {
    this->_xsd_count_.set (count);
  }

  void select_request_type::
  count (const count::container& count)
  {
    this->_xsd_count_ = count;
  }


  // rowType
  // 

  const rowType::field::container& rowType::
  field () const
  {
    return this->_xsd_field_;
  }

  rowType::field::container& rowType::
  field ()
  {
    return this->_xsd_field_;
  }

  void rowType::
  field (const field::container& field)
  {
    this->_xsd_field_ = field;
  }


  // select_reply_type
  // 

  const select_reply_type::row::container& select_reply_type::
  row () const
  {
    return this->_xsd_row_;
  }

  select_reply_type::row::container& select_reply_type::
  row ()
  {
    return this->_xsd_row_;
  }

  void select_reply_type::
  row (const row::container& row)
  {
    this->_xsd_row_ = row;
  }


  // eval_request_type
  // 

  const eval_request_type::expr::type& eval_request_type::
  expr () const
  {
    return this->_xsd_expr_.get ();
  }

  eval_request_type::expr::type& eval_request_type::
  expr ()
  {
    return this->_xsd_expr_.get ();
  }

  void eval_request_type::
  expr (const expr::type& expr)
  {
    this->_xsd_expr_.set (expr);
  }

  void eval_request_type::
  expr (::std::auto_ptr< expr::type > expr)
  {
    this->_xsd_expr_.set (expr);
  }

  const eval_request_type::handle::type& eval_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  eval_request_type::handle::type& eval_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void eval_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void eval_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const eval_request_type::language::type& eval_request_type::
  language () const
  {
    return this->_xsd_language_.get ();
  }

  eval_request_type::language::type& eval_request_type::
  language ()
  {
    return this->_xsd_language_.get ();
  }

  void eval_request_type::
  language (const language::type& language)
  {
    this->_xsd_language_.set (language);
  }

  void eval_request_type::
  language (::std::auto_ptr< language::type > language)
  {
    this->_xsd_language_.set (language);
  }


  // eval_reply_type
  // 

  const eval_reply_type::value::type& eval_reply_type::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  eval_reply_type::value::type& eval_reply_type::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void eval_reply_type::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void eval_reply_type::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const eval_reply_type::language::type& eval_reply_type::
  language () const
  {
    return this->_xsd_language_.get ();
  }

  eval_reply_type::language::type& eval_reply_type::
  language ()
  {
    return this->_xsd_language_.get ();
  }

  void eval_reply_type::
  language (const language::type& language)
  {
    this->_xsd_language_.set (language);
  }

  void eval_reply_type::
  language (::std::auto_ptr< language::type > language)
  {
    this->_xsd_language_.set (language);
  }


  // trigger_request_type
  // 

  const trigger_request_type::expr::type& trigger_request_type::
  expr () const
  {
    return this->_xsd_expr_.get ();
  }

  trigger_request_type::expr::type& trigger_request_type::
  expr ()
  {
    return this->_xsd_expr_.get ();
  }

  void trigger_request_type::
  expr (const expr::type& expr)
  {
    this->_xsd_expr_.set (expr);
  }

  void trigger_request_type::
  expr (::std::auto_ptr< expr::type > expr)
  {
    this->_xsd_expr_.set (expr);
  }

  const trigger_request_type::handle::type& trigger_request_type::
  handle () const
  {
    return this->_xsd_handle_.get ();
  }

  trigger_request_type::handle::type& trigger_request_type::
  handle ()
  {
    return this->_xsd_handle_.get ();
  }

  void trigger_request_type::
  handle (const handle::type& handle)
  {
    this->_xsd_handle_.set (handle);
  }

  void trigger_request_type::
  handle (::std::auto_ptr< handle::type > handle)
  {
    this->_xsd_handle_.set (handle);
  }

  const trigger_request_type::language::type& trigger_request_type::
  language () const
  {
    return this->_xsd_language_.get ();
  }

  trigger_request_type::language::type& trigger_request_type::
  language ()
  {
    return this->_xsd_language_.get ();
  }

  void trigger_request_type::
  language (const language::type& language)
  {
    this->_xsd_language_.set (language);
  }

  void trigger_request_type::
  language (::std::auto_ptr< language::type > language)
  {
    this->_xsd_language_.set (language);
  }


  // trigger_reply_type
  // 

  const trigger_reply_type::value::type& trigger_reply_type::
  value () const
  {
    return this->_xsd_value_.get ();
  }

  trigger_reply_type::value::type& trigger_reply_type::
  value ()
  {
    return this->_xsd_value_.get ();
  }

  void trigger_reply_type::
  value (const value::type& value)
  {
    this->_xsd_value_.set (value);
  }

  void trigger_reply_type::
  value (::std::auto_ptr< value::type > value)
  {
    this->_xsd_value_.set (value);
  }

  const trigger_reply_type::language::type& trigger_reply_type::
  language () const
  {
    return this->_xsd_language_.get ();
  }

  trigger_reply_type::language::type& trigger_reply_type::
  language ()
  {
    return this->_xsd_language_.get ();
  }

  void trigger_reply_type::
  language (const language::type& language)
  {
    this->_xsd_language_.set (language);
  }

  void trigger_reply_type::
  language (::std::auto_ptr< language::type > language)
  {
    this->_xsd_language_.set (language);
  }


  // ds_request_type
  // 

  const ds_request_type::ds_caps::container& ds_request_type::
  ds_caps () const
  {
    return this->_xsd_ds_caps_;
  }

  ds_request_type::ds_caps::container& ds_request_type::
  ds_caps ()
  {
    return this->_xsd_ds_caps_;
  }

  void ds_request_type::
  ds_caps (const ds_caps::type& ds_caps)
  {
    this->_xsd_ds_caps_.set (ds_caps);
  }

  void ds_request_type::
  ds_caps (const ds_caps::container& ds_caps)
  {
    this->_xsd_ds_caps_ = ds_caps;
  }

  void ds_request_type::
  ds_caps (::std::auto_ptr< ds_caps::type > ds_caps)
  {
    this->_xsd_ds_caps_.set (ds_caps);
  }

  const ds_request_type::ds_create::container& ds_request_type::
  ds_create () const
  {
    return this->_xsd_ds_create_;
  }

  ds_request_type::ds_create::container& ds_request_type::
  ds_create ()
  {
    return this->_xsd_ds_create_;
  }

  void ds_request_type::
  ds_create (const ds_create::type& ds_create)
  {
    this->_xsd_ds_create_.set (ds_create);
  }

  void ds_request_type::
  ds_create (const ds_create::container& ds_create)
  {
    this->_xsd_ds_create_ = ds_create;
  }

  void ds_request_type::
  ds_create (::std::auto_ptr< ds_create::type > ds_create)
  {
    this->_xsd_ds_create_.set (ds_create);
  }

  const ds_request_type::ds_del::container& ds_request_type::
  ds_del () const
  {
    return this->_xsd_ds_del_;
  }

  ds_request_type::ds_del::container& ds_request_type::
  ds_del ()
  {
    return this->_xsd_ds_del_;
  }

  void ds_request_type::
  ds_del (const ds_del::type& ds_del)
  {
    this->_xsd_ds_del_.set (ds_del);
  }

  void ds_request_type::
  ds_del (const ds_del::container& ds_del)
  {
    this->_xsd_ds_del_ = ds_del;
  }

  void ds_request_type::
  ds_del (::std::auto_ptr< ds_del::type > ds_del)
  {
    this->_xsd_ds_del_.set (ds_del);
  }

  const ds_request_type::ds_open::container& ds_request_type::
  ds_open () const
  {
    return this->_xsd_ds_open_;
  }

  ds_request_type::ds_open::container& ds_request_type::
  ds_open ()
  {
    return this->_xsd_ds_open_;
  }

  void ds_request_type::
  ds_open (const ds_open::type& ds_open)
  {
    this->_xsd_ds_open_.set (ds_open);
  }

  void ds_request_type::
  ds_open (const ds_open::container& ds_open)
  {
    this->_xsd_ds_open_ = ds_open;
  }

  void ds_request_type::
  ds_open (::std::auto_ptr< ds_open::type > ds_open)
  {
    this->_xsd_ds_open_.set (ds_open);
  }

  const ds_request_type::ds_stat::container& ds_request_type::
  ds_stat () const
  {
    return this->_xsd_ds_stat_;
  }

  ds_request_type::ds_stat::container& ds_request_type::
  ds_stat ()
  {
    return this->_xsd_ds_stat_;
  }

  void ds_request_type::
  ds_stat (const ds_stat::type& ds_stat)
  {
    this->_xsd_ds_stat_.set (ds_stat);
  }

  void ds_request_type::
  ds_stat (const ds_stat::container& ds_stat)
  {
    this->_xsd_ds_stat_ = ds_stat;
  }

  void ds_request_type::
  ds_stat (::std::auto_ptr< ds_stat::type > ds_stat)
  {
    this->_xsd_ds_stat_.set (ds_stat);
  }

  const ds_request_type::ds_close::container& ds_request_type::
  ds_close () const
  {
    return this->_xsd_ds_close_;
  }

  ds_request_type::ds_close::container& ds_request_type::
  ds_close ()
  {
    return this->_xsd_ds_close_;
  }

  void ds_request_type::
  ds_close (const ds_close::type& ds_close)
  {
    this->_xsd_ds_close_.set (ds_close);
  }

  void ds_request_type::
  ds_close (const ds_close::container& ds_close)
  {
    this->_xsd_ds_close_ = ds_close;
  }

  void ds_request_type::
  ds_close (::std::auto_ptr< ds_close::type > ds_close)
  {
    this->_xsd_ds_close_.set (ds_close);
  }

  const ds_request_type::table_create::container& ds_request_type::
  table_create () const
  {
    return this->_xsd_table_create_;
  }

  ds_request_type::table_create::container& ds_request_type::
  table_create ()
  {
    return this->_xsd_table_create_;
  }

  void ds_request_type::
  table_create (const table_create::type& table_create)
  {
    this->_xsd_table_create_.set (table_create);
  }

  void ds_request_type::
  table_create (const table_create::container& table_create)
  {
    this->_xsd_table_create_ = table_create;
  }

  void ds_request_type::
  table_create (::std::auto_ptr< table_create::type > table_create)
  {
    this->_xsd_table_create_.set (table_create);
  }

  const ds_request_type::table_del::container& ds_request_type::
  table_del () const
  {
    return this->_xsd_table_del_;
  }

  ds_request_type::table_del::container& ds_request_type::
  table_del ()
  {
    return this->_xsd_table_del_;
  }

  void ds_request_type::
  table_del (const table_del::type& table_del)
  {
    this->_xsd_table_del_.set (table_del);
  }

  void ds_request_type::
  table_del (const table_del::container& table_del)
  {
    this->_xsd_table_del_ = table_del;
  }

  void ds_request_type::
  table_del (::std::auto_ptr< table_del::type > table_del)
  {
    this->_xsd_table_del_.set (table_del);
  }

  const ds_request_type::table_stat::container& ds_request_type::
  table_stat () const
  {
    return this->_xsd_table_stat_;
  }

  ds_request_type::table_stat::container& ds_request_type::
  table_stat ()
  {
    return this->_xsd_table_stat_;
  }

  void ds_request_type::
  table_stat (const table_stat::type& table_stat)
  {
    this->_xsd_table_stat_.set (table_stat);
  }

  void ds_request_type::
  table_stat (const table_stat::container& table_stat)
  {
    this->_xsd_table_stat_ = table_stat;
  }

  void ds_request_type::
  table_stat (::std::auto_ptr< table_stat::type > table_stat)
  {
    this->_xsd_table_stat_.set (table_stat);
  }

  const ds_request_type::table_keys::container& ds_request_type::
  table_keys () const
  {
    return this->_xsd_table_keys_;
  }

  ds_request_type::table_keys::container& ds_request_type::
  table_keys ()
  {
    return this->_xsd_table_keys_;
  }

  void ds_request_type::
  table_keys (const table_keys::type& table_keys)
  {
    this->_xsd_table_keys_.set (table_keys);
  }

  void ds_request_type::
  table_keys (const table_keys::container& table_keys)
  {
    this->_xsd_table_keys_ = table_keys;
  }

  void ds_request_type::
  table_keys (::std::auto_ptr< table_keys::type > table_keys)
  {
    this->_xsd_table_keys_.set (table_keys);
  }

  const ds_request_type::put::container& ds_request_type::
  put () const
  {
    return this->_xsd_put_;
  }

  ds_request_type::put::container& ds_request_type::
  put ()
  {
    return this->_xsd_put_;
  }

  void ds_request_type::
  put (const put::type& put)
  {
    this->_xsd_put_.set (put);
  }

  void ds_request_type::
  put (const put::container& put)
  {
    this->_xsd_put_ = put;
  }

  void ds_request_type::
  put (::std::auto_ptr< put::type > put)
  {
    this->_xsd_put_.set (put);
  }

  const ds_request_type::get::container& ds_request_type::
  get () const
  {
    return this->_xsd_get_;
  }

  ds_request_type::get::container& ds_request_type::
  get ()
  {
    return this->_xsd_get_;
  }

  void ds_request_type::
  get (const get::type& get)
  {
    this->_xsd_get_.set (get);
  }

  void ds_request_type::
  get (const get::container& get)
  {
    this->_xsd_get_ = get;
  }

  void ds_request_type::
  get (::std::auto_ptr< get::type > get)
  {
    this->_xsd_get_.set (get);
  }

  const ds_request_type::del::container& ds_request_type::
  del () const
  {
    return this->_xsd_del_;
  }

  ds_request_type::del::container& ds_request_type::
  del ()
  {
    return this->_xsd_del_;
  }

  void ds_request_type::
  del (const del::type& del)
  {
    this->_xsd_del_.set (del);
  }

  void ds_request_type::
  del (const del::container& del)
  {
    this->_xsd_del_ = del;
  }

  void ds_request_type::
  del (::std::auto_ptr< del::type > del)
  {
    this->_xsd_del_.set (del);
  }

  const ds_request_type::select::container& ds_request_type::
  select () const
  {
    return this->_xsd_select_;
  }

  ds_request_type::select::container& ds_request_type::
  select ()
  {
    return this->_xsd_select_;
  }

  void ds_request_type::
  select (const select::type& select)
  {
    this->_xsd_select_.set (select);
  }

  void ds_request_type::
  select (const select::container& select)
  {
    this->_xsd_select_ = select;
  }

  void ds_request_type::
  select (::std::auto_ptr< select::type > select)
  {
    this->_xsd_select_.set (select);
  }

  const ds_request_type::eval::container& ds_request_type::
  eval () const
  {
    return this->_xsd_eval_;
  }

  ds_request_type::eval::container& ds_request_type::
  eval ()
  {
    return this->_xsd_eval_;
  }

  void ds_request_type::
  eval (const eval::type& eval)
  {
    this->_xsd_eval_.set (eval);
  }

  void ds_request_type::
  eval (const eval::container& eval)
  {
    this->_xsd_eval_ = eval;
  }

  void ds_request_type::
  eval (::std::auto_ptr< eval::type > eval)
  {
    this->_xsd_eval_.set (eval);
  }

  const ds_request_type::trigger::container& ds_request_type::
  trigger () const
  {
    return this->_xsd_trigger_;
  }

  ds_request_type::trigger::container& ds_request_type::
  trigger ()
  {
    return this->_xsd_trigger_;
  }

  void ds_request_type::
  trigger (const trigger::type& trigger)
  {
    this->_xsd_trigger_.set (trigger);
  }

  void ds_request_type::
  trigger (const trigger::container& trigger)
  {
    this->_xsd_trigger_ = trigger;
  }

  void ds_request_type::
  trigger (::std::auto_ptr< trigger::type > trigger)
  {
    this->_xsd_trigger_.set (trigger);
  }

  const ds_request_type::cookie::type& ds_request_type::
  cookie () const
  {
    return this->_xsd_cookie_.get ();
  }

  ds_request_type::cookie::type& ds_request_type::
  cookie ()
  {
    return this->_xsd_cookie_.get ();
  }

  void ds_request_type::
  cookie (const cookie::type& cookie)
  {
    this->_xsd_cookie_.set (cookie);
  }

  void ds_request_type::
  cookie (::std::auto_ptr< cookie::type > cookie)
  {
    this->_xsd_cookie_.set (cookie);
  }


  // ds_reply_type
  // 

  const ds_reply_type::ds_caps_reply::container& ds_reply_type::
  ds_caps_reply () const
  {
    return this->_xsd_ds_caps_reply_;
  }

  ds_reply_type::ds_caps_reply::container& ds_reply_type::
  ds_caps_reply ()
  {
    return this->_xsd_ds_caps_reply_;
  }

  void ds_reply_type::
  ds_caps_reply (const ds_caps_reply::type& ds_caps_reply)
  {
    this->_xsd_ds_caps_reply_.set (ds_caps_reply);
  }

  void ds_reply_type::
  ds_caps_reply (const ds_caps_reply::container& ds_caps_reply)
  {
    this->_xsd_ds_caps_reply_ = ds_caps_reply;
  }

  void ds_reply_type::
  ds_caps_reply (::std::auto_ptr< ds_caps_reply::type > ds_caps_reply)
  {
    this->_xsd_ds_caps_reply_.set (ds_caps_reply);
  }

  const ds_reply_type::ds_create_reply::container& ds_reply_type::
  ds_create_reply () const
  {
    return this->_xsd_ds_create_reply_;
  }

  ds_reply_type::ds_create_reply::container& ds_reply_type::
  ds_create_reply ()
  {
    return this->_xsd_ds_create_reply_;
  }

  void ds_reply_type::
  ds_create_reply (const ds_create_reply::type& ds_create_reply)
  {
    this->_xsd_ds_create_reply_.set (ds_create_reply);
  }

  void ds_reply_type::
  ds_create_reply (const ds_create_reply::container& ds_create_reply)
  {
    this->_xsd_ds_create_reply_ = ds_create_reply;
  }

  void ds_reply_type::
  ds_create_reply (::std::auto_ptr< ds_create_reply::type > ds_create_reply)
  {
    this->_xsd_ds_create_reply_.set (ds_create_reply);
  }

  const ds_reply_type::ds_del_reply::container& ds_reply_type::
  ds_del_reply () const
  {
    return this->_xsd_ds_del_reply_;
  }

  ds_reply_type::ds_del_reply::container& ds_reply_type::
  ds_del_reply ()
  {
    return this->_xsd_ds_del_reply_;
  }

  void ds_reply_type::
  ds_del_reply (const ds_del_reply::type& ds_del_reply)
  {
    this->_xsd_ds_del_reply_.set (ds_del_reply);
  }

  void ds_reply_type::
  ds_del_reply (const ds_del_reply::container& ds_del_reply)
  {
    this->_xsd_ds_del_reply_ = ds_del_reply;
  }

  void ds_reply_type::
  ds_del_reply (::std::auto_ptr< ds_del_reply::type > ds_del_reply)
  {
    this->_xsd_ds_del_reply_.set (ds_del_reply);
  }

  const ds_reply_type::ds_open_reply::container& ds_reply_type::
  ds_open_reply () const
  {
    return this->_xsd_ds_open_reply_;
  }

  ds_reply_type::ds_open_reply::container& ds_reply_type::
  ds_open_reply ()
  {
    return this->_xsd_ds_open_reply_;
  }

  void ds_reply_type::
  ds_open_reply (const ds_open_reply::type& ds_open_reply)
  {
    this->_xsd_ds_open_reply_.set (ds_open_reply);
  }

  void ds_reply_type::
  ds_open_reply (const ds_open_reply::container& ds_open_reply)
  {
    this->_xsd_ds_open_reply_ = ds_open_reply;
  }

  void ds_reply_type::
  ds_open_reply (::std::auto_ptr< ds_open_reply::type > ds_open_reply)
  {
    this->_xsd_ds_open_reply_.set (ds_open_reply);
  }

  const ds_reply_type::ds_stat_reply::container& ds_reply_type::
  ds_stat_reply () const
  {
    return this->_xsd_ds_stat_reply_;
  }

  ds_reply_type::ds_stat_reply::container& ds_reply_type::
  ds_stat_reply ()
  {
    return this->_xsd_ds_stat_reply_;
  }

  void ds_reply_type::
  ds_stat_reply (const ds_stat_reply::type& ds_stat_reply)
  {
    this->_xsd_ds_stat_reply_.set (ds_stat_reply);
  }

  void ds_reply_type::
  ds_stat_reply (const ds_stat_reply::container& ds_stat_reply)
  {
    this->_xsd_ds_stat_reply_ = ds_stat_reply;
  }

  void ds_reply_type::
  ds_stat_reply (::std::auto_ptr< ds_stat_reply::type > ds_stat_reply)
  {
    this->_xsd_ds_stat_reply_.set (ds_stat_reply);
  }

  const ds_reply_type::ds_close_reply::container& ds_reply_type::
  ds_close_reply () const
  {
    return this->_xsd_ds_close_reply_;
  }

  ds_reply_type::ds_close_reply::container& ds_reply_type::
  ds_close_reply ()
  {
    return this->_xsd_ds_close_reply_;
  }

  void ds_reply_type::
  ds_close_reply (const ds_close_reply::type& ds_close_reply)
  {
    this->_xsd_ds_close_reply_.set (ds_close_reply);
  }

  void ds_reply_type::
  ds_close_reply (const ds_close_reply::container& ds_close_reply)
  {
    this->_xsd_ds_close_reply_ = ds_close_reply;
  }

  void ds_reply_type::
  ds_close_reply (::std::auto_ptr< ds_close_reply::type > ds_close_reply)
  {
    this->_xsd_ds_close_reply_.set (ds_close_reply);
  }

  const ds_reply_type::table_create_reply::container& ds_reply_type::
  table_create_reply () const
  {
    return this->_xsd_table_create_reply_;
  }

  ds_reply_type::table_create_reply::container& ds_reply_type::
  table_create_reply ()
  {
    return this->_xsd_table_create_reply_;
  }

  void ds_reply_type::
  table_create_reply (const table_create_reply::type& table_create_reply)
  {
    this->_xsd_table_create_reply_.set (table_create_reply);
  }

  void ds_reply_type::
  table_create_reply (const table_create_reply::container& table_create_reply)
  {
    this->_xsd_table_create_reply_ = table_create_reply;
  }

  void ds_reply_type::
  table_create_reply (::std::auto_ptr< table_create_reply::type > table_create_reply)
  {
    this->_xsd_table_create_reply_.set (table_create_reply);
  }

  const ds_reply_type::table_del_reply::container& ds_reply_type::
  table_del_reply () const
  {
    return this->_xsd_table_del_reply_;
  }

  ds_reply_type::table_del_reply::container& ds_reply_type::
  table_del_reply ()
  {
    return this->_xsd_table_del_reply_;
  }

  void ds_reply_type::
  table_del_reply (const table_del_reply::type& table_del_reply)
  {
    this->_xsd_table_del_reply_.set (table_del_reply);
  }

  void ds_reply_type::
  table_del_reply (const table_del_reply::container& table_del_reply)
  {
    this->_xsd_table_del_reply_ = table_del_reply;
  }

  void ds_reply_type::
  table_del_reply (::std::auto_ptr< table_del_reply::type > table_del_reply)
  {
    this->_xsd_table_del_reply_.set (table_del_reply);
  }

  const ds_reply_type::table_stat_reply::container& ds_reply_type::
  table_stat_reply () const
  {
    return this->_xsd_table_stat_reply_;
  }

  ds_reply_type::table_stat_reply::container& ds_reply_type::
  table_stat_reply ()
  {
    return this->_xsd_table_stat_reply_;
  }

  void ds_reply_type::
  table_stat_reply (const table_stat_reply::type& table_stat_reply)
  {
    this->_xsd_table_stat_reply_.set (table_stat_reply);
  }

  void ds_reply_type::
  table_stat_reply (const table_stat_reply::container& table_stat_reply)
  {
    this->_xsd_table_stat_reply_ = table_stat_reply;
  }

  void ds_reply_type::
  table_stat_reply (::std::auto_ptr< table_stat_reply::type > table_stat_reply)
  {
    this->_xsd_table_stat_reply_.set (table_stat_reply);
  }

  const ds_reply_type::table_keys_reply::container& ds_reply_type::
  table_keys_reply () const
  {
    return this->_xsd_table_keys_reply_;
  }

  ds_reply_type::table_keys_reply::container& ds_reply_type::
  table_keys_reply ()
  {
    return this->_xsd_table_keys_reply_;
  }

  void ds_reply_type::
  table_keys_reply (const table_keys_reply::type& table_keys_reply)
  {
    this->_xsd_table_keys_reply_.set (table_keys_reply);
  }

  void ds_reply_type::
  table_keys_reply (const table_keys_reply::container& table_keys_reply)
  {
    this->_xsd_table_keys_reply_ = table_keys_reply;
  }

  void ds_reply_type::
  table_keys_reply (::std::auto_ptr< table_keys_reply::type > table_keys_reply)
  {
    this->_xsd_table_keys_reply_.set (table_keys_reply);
  }

  const ds_reply_type::put_reply::container& ds_reply_type::
  put_reply () const
  {
    return this->_xsd_put_reply_;
  }

  ds_reply_type::put_reply::container& ds_reply_type::
  put_reply ()
  {
    return this->_xsd_put_reply_;
  }

  void ds_reply_type::
  put_reply (const put_reply::type& put_reply)
  {
    this->_xsd_put_reply_.set (put_reply);
  }

  void ds_reply_type::
  put_reply (const put_reply::container& put_reply)
  {
    this->_xsd_put_reply_ = put_reply;
  }

  void ds_reply_type::
  put_reply (::std::auto_ptr< put_reply::type > put_reply)
  {
    this->_xsd_put_reply_.set (put_reply);
  }

  const ds_reply_type::get_reply::container& ds_reply_type::
  get_reply () const
  {
    return this->_xsd_get_reply_;
  }

  ds_reply_type::get_reply::container& ds_reply_type::
  get_reply ()
  {
    return this->_xsd_get_reply_;
  }

  void ds_reply_type::
  get_reply (const get_reply::type& get_reply)
  {
    this->_xsd_get_reply_.set (get_reply);
  }

  void ds_reply_type::
  get_reply (const get_reply::container& get_reply)
  {
    this->_xsd_get_reply_ = get_reply;
  }

  void ds_reply_type::
  get_reply (::std::auto_ptr< get_reply::type > get_reply)
  {
    this->_xsd_get_reply_.set (get_reply);
  }

  const ds_reply_type::del_reply::container& ds_reply_type::
  del_reply () const
  {
    return this->_xsd_del_reply_;
  }

  ds_reply_type::del_reply::container& ds_reply_type::
  del_reply ()
  {
    return this->_xsd_del_reply_;
  }

  void ds_reply_type::
  del_reply (const del_reply::type& del_reply)
  {
    this->_xsd_del_reply_.set (del_reply);
  }

  void ds_reply_type::
  del_reply (const del_reply::container& del_reply)
  {
    this->_xsd_del_reply_ = del_reply;
  }

  void ds_reply_type::
  del_reply (::std::auto_ptr< del_reply::type > del_reply)
  {
    this->_xsd_del_reply_.set (del_reply);
  }

  const ds_reply_type::select_reply::container& ds_reply_type::
  select_reply () const
  {
    return this->_xsd_select_reply_;
  }

  ds_reply_type::select_reply::container& ds_reply_type::
  select_reply ()
  {
    return this->_xsd_select_reply_;
  }

  void ds_reply_type::
  select_reply (const select_reply::type& select_reply)
  {
    this->_xsd_select_reply_.set (select_reply);
  }

  void ds_reply_type::
  select_reply (const select_reply::container& select_reply)
  {
    this->_xsd_select_reply_ = select_reply;
  }

  void ds_reply_type::
  select_reply (::std::auto_ptr< select_reply::type > select_reply)
  {
    this->_xsd_select_reply_.set (select_reply);
  }

  const ds_reply_type::eval_reply::container& ds_reply_type::
  eval_reply () const
  {
    return this->_xsd_eval_reply_;
  }

  ds_reply_type::eval_reply::container& ds_reply_type::
  eval_reply ()
  {
    return this->_xsd_eval_reply_;
  }

  void ds_reply_type::
  eval_reply (const eval_reply::type& eval_reply)
  {
    this->_xsd_eval_reply_.set (eval_reply);
  }

  void ds_reply_type::
  eval_reply (const eval_reply::container& eval_reply)
  {
    this->_xsd_eval_reply_ = eval_reply;
  }

  void ds_reply_type::
  eval_reply (::std::auto_ptr< eval_reply::type > eval_reply)
  {
    this->_xsd_eval_reply_.set (eval_reply);
  }

  const ds_reply_type::trigger_reply::container& ds_reply_type::
  trigger_reply () const
  {
    return this->_xsd_trigger_reply_;
  }

  ds_reply_type::trigger_reply::container& ds_reply_type::
  trigger_reply ()
  {
    return this->_xsd_trigger_reply_;
  }

  void ds_reply_type::
  trigger_reply (const trigger_reply::type& trigger_reply)
  {
    this->_xsd_trigger_reply_.set (trigger_reply);
  }

  void ds_reply_type::
  trigger_reply (const trigger_reply::container& trigger_reply)
  {
    this->_xsd_trigger_reply_ = trigger_reply;
  }

  void ds_reply_type::
  trigger_reply (::std::auto_ptr< trigger_reply::type > trigger_reply)
  {
    this->_xsd_trigger_reply_.set (trigger_reply);
  }

  const ds_reply_type::cookie::type& ds_reply_type::
  cookie () const
  {
    return this->_xsd_cookie_.get ();
  }

  ds_reply_type::cookie::type& ds_reply_type::
  cookie ()
  {
    return this->_xsd_cookie_.get ();
  }

  void ds_reply_type::
  cookie (const cookie::type& cookie)
  {
    this->_xsd_cookie_.set (cookie);
  }

  void ds_reply_type::
  cookie (::std::auto_ptr< cookie::type > cookie)
  {
    this->_xsd_cookie_.set (cookie);
  }

  const ds_reply_type::error::type& ds_reply_type::
  error () const
  {
    return this->_xsd_error_.get ();
  }

  ds_reply_type::error::type& ds_reply_type::
  error ()
  {
    return this->_xsd_error_.get ();
  }

  void ds_reply_type::
  error (const error::type& error)
  {
    this->_xsd_error_.set (error);
  }

  void ds_reply_type::
  error (::std::auto_ptr< error::type > error)
  {
    this->_xsd_error_.set (error);
  }
}

#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

namespace dsmessage
{
  // storeType
  //

  storeType::
  storeType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_storeType_convert ();
  }

  storeType::
  storeType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_storeType_convert ();
  }

  storeType::
  storeType (const ::std::basic_string< char >& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_storeType_convert ();
  }

  storeType* storeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new storeType (*this, f, c);
  }

  storeType::_xsd_storeType storeType::
  _xsd_storeType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_storeType_literals_);
    const _xsd_storeType* i (::std::lower_bound (
                               _xsd_storeType_indexes_,
                               _xsd_storeType_indexes_ + 3,
                               *this,
                               c));

    if (i == _xsd_storeType_indexes_ + 3 || _xsd_storeType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const storeType::
  _xsd_storeType_literals_[3] =
  {
    "pair",
    "field",
    "advanced"
  };

  const storeType::_xsd_storeType storeType::
  _xsd_storeType_indexes_[3] =
  {
    ::dsmessage::storeType::advanced,
    ::dsmessage::storeType::field,
    ::dsmessage::storeType::pair
  };

  // tableInfoType
  //

  tableInfoType::
  tableInfoType (const table::type& _xsd_table)
  : ::xml_schema::type (),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this)
  {
  }

  tableInfoType::
  tableInfoType (const tableInfoType& _xsd_tableInfoType,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_tableInfoType, f, c),
  _xsd_table_ (_xsd_tableInfoType._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  tableInfoType::
  tableInfoType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void tableInfoType::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }
  }

  tableInfoType* tableInfoType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new tableInfoType (*this, f, c);
  }

  // fieldType
  //

  fieldType::
  fieldType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_fieldType_convert ();
  }

  fieldType::
  fieldType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_fieldType_convert ();
  }

  fieldType::
  fieldType (const ::std::basic_string< char >& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_fieldType_convert ();
  }

  fieldType* fieldType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new fieldType (*this, f, c);
  }

  fieldType::_xsd_fieldType fieldType::
  _xsd_fieldType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fieldType_literals_);
    const _xsd_fieldType* i (::std::lower_bound (
                               _xsd_fieldType_indexes_,
                               _xsd_fieldType_indexes_ + 4,
                               *this,
                               c));

    if (i == _xsd_fieldType_indexes_ + 4 || _xsd_fieldType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const fieldType::
  _xsd_fieldType_literals_[4] =
  {
    "integer",
    "float",
    "string",
    "boolean"
  };

  const fieldType::_xsd_fieldType fieldType::
  _xsd_fieldType_indexes_[4] =
  {
    ::dsmessage::fieldType::boolean,
    ::dsmessage::fieldType::float_,
    ::dsmessage::fieldType::integer,
    ::dsmessage::fieldType::string
  };

  // fieldInfoType
  //

  fieldInfoType::
  fieldInfoType (const field::type& _xsd_field,
                 const type::type_& _xsd_type)
  : ::xml_schema::type (),
  _xsd_field_ (_xsd_field,
               ::xml_schema::flags (),
               this),
  _xsd_type_ (_xsd_type,
              ::xml_schema::flags (),
              this)
  {
  }

  fieldInfoType::
  fieldInfoType (const fieldInfoType& _xsd_fieldInfoType,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_fieldInfoType, f, c),
  _xsd_field_ (_xsd_fieldInfoType._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_type_ (_xsd_fieldInfoType._xsd_type_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  fieldInfoType::
  fieldInfoType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this),
  _xsd_type_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void fieldInfoType::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "field" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< field::type > r (
          field::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->field (r);
        continue;
      }

      if (a.name () == "type" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< type::type_ > r (
          type::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->type (r);
        continue;
      }
    }

    if (!_xsd_field_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field",
        "");
    }

    if (!_xsd_type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  fieldInfoType* fieldInfoType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new fieldInfoType (*this, f, c);
  }

  // fieldNameValue
  //

  fieldNameValue::
  fieldNameValue (const value::type& _xsd_value,
                  const field::type& _xsd_field)
  : ::xml_schema::type (),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_field_ (_xsd_field,
               ::xml_schema::flags (),
               this)
  {
  }

  fieldNameValue::
  fieldNameValue (const fieldNameValue& _xsd_fieldNameValue,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_fieldNameValue, f, c),
  _xsd_value_ (_xsd_fieldNameValue._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_field_ (_xsd_fieldNameValue._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  fieldNameValue::
  fieldNameValue (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void fieldNameValue::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // value
      //
      {
        if (e.name () == "value" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< value::type > r (
            value::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_value_.present ())
            continue;
          this->value (r);
          continue;
        }
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "field" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< field::type > r (
          field::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->field (r);
        continue;
      }
    }

    if (!_xsd_field_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field",
        "");
    }
  }

  fieldNameValue* fieldNameValue::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new fieldNameValue (*this, f, c);
  }

  // fieldName
  //

  fieldName::
  fieldName (const field::type& _xsd_field)
  : ::xml_schema::type (),
  _xsd_field_ (_xsd_field,
               ::xml_schema::flags (),
               this)
  {
  }

  fieldName::
  fieldName (const fieldName& _xsd_fieldName,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_fieldName, f, c),
  _xsd_field_ (_xsd_fieldName._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  fieldName::
  fieldName (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void fieldName::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "field" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< field::type > r (
          field::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->field (r);
        continue;
      }
    }

    if (!_xsd_field_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "field",
        "");
    }
  }

  fieldName* fieldName::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new fieldName (*this, f, c);
  }

  // languageName
  //

  languageName::
  languageName (const language::type& _xsd_language)
  : ::xml_schema::type (),
  _xsd_language_ (_xsd_language,
                  ::xml_schema::flags (),
                  this)
  {
  }

  languageName::
  languageName (const languageName& _xsd_languageName,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_languageName, f, c),
  _xsd_language_ (_xsd_languageName._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  languageName::
  languageName (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void languageName::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "language" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< language::type > r (
          language::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->language (r);
        continue;
      }
    }

    if (!_xsd_language_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "language",
        "");
    }
  }

  languageName* languageName::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new languageName (*this, f, c);
  }

  // ds_caps_request_type
  //

  ds_caps_request_type::
  ds_caps_request_type ()
  : ::xml_schema::type ()
  {
  }

  ds_caps_request_type::
  ds_caps_request_type (const ds_caps_request_type& _xsd_ds_caps_request_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_caps_request_type, f, c)
  {
  }

  ds_caps_request_type::
  ds_caps_request_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ds_caps_request_type::
  ds_caps_request_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ds_caps_request_type::
  ds_caps_request_type (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ds_caps_request_type* ds_caps_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_caps_request_type (*this, f, c);
  }

  // ds_caps_reply_type
  //

  ds_caps_reply_type::
  ds_caps_reply_type (const storetype::type& _xsd_storetype,
                      const supports_trigger::type& _xsd_supports_trigger)
  : ::xml_schema::type (),
  _xsd_language_ (::xml_schema::flags (), this),
  _xsd_storetype_ (_xsd_storetype,
                   ::xml_schema::flags (),
                   this),
  _xsd_supports_trigger_ (_xsd_supports_trigger,
                          ::xml_schema::flags (),
                          this)
  {
  }

  ds_caps_reply_type::
  ds_caps_reply_type (const ds_caps_reply_type& _xsd_ds_caps_reply_type,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_caps_reply_type, f, c),
  _xsd_language_ (_xsd_ds_caps_reply_type._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_storetype_ (_xsd_ds_caps_reply_type._xsd_storetype_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_supports_trigger_ (_xsd_ds_caps_reply_type._xsd_supports_trigger_,
                          f | ::xml_schema::flags::not_root,
                          this)
  {
  }

  ds_caps_reply_type::
  ds_caps_reply_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this),
  _xsd_storetype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_supports_trigger_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_caps_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // language
      //
      {
        if (e.name () == "language" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< language::type > r (
            language::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->language ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "storetype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< storetype::type > r (
          storetype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->storetype (r);
        continue;
      }

      if (a.name () == "supports-trigger" && a.namespace_ ().empty ())
      {
        this->supports_trigger (
          supports_trigger::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    if (!_xsd_storetype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "storetype",
        "");
    }

    if (!_xsd_supports_trigger_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "supports-trigger",
        "");
    }
  }

  ds_caps_reply_type* ds_caps_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_caps_reply_type (*this, f, c);
  }

  // ds_create_request_type
  //

  ds_create_request_type::
  ds_create_request_type (const ds::type& _xsd_ds)
  : ::xml_schema::type (),
  _xsd_password_ (::xml_schema::flags (), this),
  _xsd_ds_ (_xsd_ds,
            ::xml_schema::flags (),
            this),
  _xsd_clear_ (::xml_schema::flags (), this),
  _xsd_quota_ (::xml_schema::flags (), this),
  _xsd_user_ (::xml_schema::flags (), this)
  {
  }

  ds_create_request_type::
  ds_create_request_type (const ds_create_request_type& _xsd_ds_create_request_type,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_create_request_type, f, c),
  _xsd_password_ (_xsd_ds_create_request_type._xsd_password_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_ds_ (_xsd_ds_create_request_type._xsd_ds_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_clear_ (_xsd_ds_create_request_type._xsd_clear_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_quota_ (_xsd_ds_create_request_type._xsd_quota_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_user_ (_xsd_ds_create_request_type._xsd_user_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  ds_create_request_type::
  ds_create_request_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_password_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_ (f | ::xml_schema::flags::not_root, this),
  _xsd_clear_ (f | ::xml_schema::flags::not_root, this),
  _xsd_quota_ (f | ::xml_schema::flags::not_root, this),
  _xsd_user_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_create_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // password
      //
      {
        if (e.name () == "password" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< password::type > r (
            password::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->password ())
            continue;
          this->password (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ds" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ds::type > r (
          ds::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ds (r);
        continue;
      }

      if (a.name () == "clear" && a.namespace_ ().empty ())
      {
        this->clear (
          clear::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }

      if (a.name () == "quota" && a.namespace_ ().empty ())
      {
        this->quota (
          quota::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }

      if (a.name () == "user" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< user::type > r (
          user::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->user (r);
        continue;
      }
    }

    if (!_xsd_ds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ds",
        "");
    }
  }

  ds_create_request_type* ds_create_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_create_request_type (*this, f, c);
  }

  // ds_create_reply_type
  //

  ds_create_reply_type::
  ds_create_reply_type ()
  : ::xml_schema::type ()
  {
  }

  ds_create_reply_type::
  ds_create_reply_type (const ds_create_reply_type& _xsd_ds_create_reply_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_create_reply_type, f, c)
  {
  }

  ds_create_reply_type::
  ds_create_reply_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ds_create_reply_type::
  ds_create_reply_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ds_create_reply_type::
  ds_create_reply_type (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ds_create_reply_type* ds_create_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_create_reply_type (*this, f, c);
  }

  // ds_del_request_type
  //

  ds_del_request_type::
  ds_del_request_type (const ds::type& _xsd_ds)
  : ::xml_schema::type (),
  _xsd_password_ (::xml_schema::flags (), this),
  _xsd_ds_ (_xsd_ds,
            ::xml_schema::flags (),
            this),
  _xsd_user_ (::xml_schema::flags (), this)
  {
  }

  ds_del_request_type::
  ds_del_request_type (const ds_del_request_type& _xsd_ds_del_request_type,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_del_request_type, f, c),
  _xsd_password_ (_xsd_ds_del_request_type._xsd_password_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_ds_ (_xsd_ds_del_request_type._xsd_ds_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_user_ (_xsd_ds_del_request_type._xsd_user_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  ds_del_request_type::
  ds_del_request_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_password_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_ (f | ::xml_schema::flags::not_root, this),
  _xsd_user_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_del_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // password
      //
      {
        if (e.name () == "password" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< password::type > r (
            password::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->password ())
            continue;
          this->password (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ds" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ds::type > r (
          ds::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ds (r);
        continue;
      }

      if (a.name () == "user" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< user::type > r (
          user::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->user (r);
        continue;
      }
    }

    if (!_xsd_ds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ds",
        "");
    }
  }

  ds_del_request_type* ds_del_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_del_request_type (*this, f, c);
  }

  // ds_del_reply_type
  //

  ds_del_reply_type::
  ds_del_reply_type ()
  : ::xml_schema::type ()
  {
  }

  ds_del_reply_type::
  ds_del_reply_type (const ds_del_reply_type& _xsd_ds_del_reply_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_del_reply_type, f, c)
  {
  }

  ds_del_reply_type::
  ds_del_reply_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ds_del_reply_type::
  ds_del_reply_type (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ds_del_reply_type::
  ds_del_reply_type (const ::std::basic_string< char >& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ds_del_reply_type* ds_del_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_del_reply_type (*this, f, c);
  }

  // ds_open_request_type
  //

  ds_open_request_type::
  ds_open_request_type (const ds::type& _xsd_ds)
  : ::xml_schema::type (),
  _xsd_password_ (::xml_schema::flags (), this),
  _xsd_ds_ (_xsd_ds,
            ::xml_schema::flags (),
            this),
  _xsd_lease_ (::xml_schema::flags (), this),
  _xsd_user_ (::xml_schema::flags (), this)
  {
  }

  ds_open_request_type::
  ds_open_request_type (const ds_open_request_type& _xsd_ds_open_request_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_open_request_type, f, c),
  _xsd_password_ (_xsd_ds_open_request_type._xsd_password_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_ds_ (_xsd_ds_open_request_type._xsd_ds_,
            f | ::xml_schema::flags::not_root,
            this),
  _xsd_lease_ (_xsd_ds_open_request_type._xsd_lease_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_user_ (_xsd_ds_open_request_type._xsd_user_,
              f | ::xml_schema::flags::not_root,
              this)
  {
  }

  ds_open_request_type::
  ds_open_request_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_password_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_ (f | ::xml_schema::flags::not_root, this),
  _xsd_lease_ (f | ::xml_schema::flags::not_root, this),
  _xsd_user_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_open_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // password
      //
      {
        if (e.name () == "password" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< password::type > r (
            password::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->password ())
            continue;
          this->password (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "ds" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< ds::type > r (
          ds::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ds (r);
        continue;
      }

      if (a.name () == "lease" && a.namespace_ ().empty ())
      {
        this->lease (
          lease::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }

      if (a.name () == "user" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< user::type > r (
          user::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->user (r);
        continue;
      }
    }

    if (!_xsd_ds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ds",
        "");
    }
  }

  ds_open_request_type* ds_open_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_open_request_type (*this, f, c);
  }

  // ds_open_reply_type
  //

  ds_open_reply_type::
  ds_open_reply_type ()
  : ::xml_schema::type (),
  _xsd_handle_ (::xml_schema::flags (), this)
  {
  }

  ds_open_reply_type::
  ds_open_reply_type (const ds_open_reply_type& _xsd_ds_open_reply_type,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_open_reply_type, f, c),
  _xsd_handle_ (_xsd_ds_open_reply_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  ds_open_reply_type::
  ds_open_reply_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_open_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }
    }
  }

  ds_open_reply_type* ds_open_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_open_reply_type (*this, f, c);
  }

  // ds_stat_request_type
  //

  ds_stat_request_type::
  ds_stat_request_type (const handle::type& _xsd_handle)
  : ::xml_schema::type (),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this)
  {
  }

  ds_stat_request_type::
  ds_stat_request_type (const ds_stat_request_type& _xsd_ds_stat_request_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_stat_request_type, f, c),
  _xsd_handle_ (_xsd_ds_stat_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  ds_stat_request_type::
  ds_stat_request_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_stat_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  ds_stat_request_type* ds_stat_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_stat_request_type (*this, f, c);
  }

  // ds_stat_reply_type
  //

  ds_stat_reply_type::
  ds_stat_reply_type ()
  : ::xml_schema::type (),
  _xsd_table_ (::xml_schema::flags (), this)
  {
  }

  ds_stat_reply_type::
  ds_stat_reply_type (const ds_stat_reply_type& _xsd_ds_stat_reply_type,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_stat_reply_type, f, c),
  _xsd_table_ (_xsd_ds_stat_reply_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  ds_stat_reply_type::
  ds_stat_reply_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_stat_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // table
      //
      {
        if (e.name () == "table" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table::type > r (
            table::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->table ().push_back (r);
          continue;
        }
      }
    }
  }

  ds_stat_reply_type* ds_stat_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_stat_reply_type (*this, f, c);
  }

  // ds_close_request_type
  //

  ds_close_request_type::
  ds_close_request_type (const handle::type& _xsd_handle)
  : ::xml_schema::type (),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this)
  {
  }

  ds_close_request_type::
  ds_close_request_type (const ds_close_request_type& _xsd_ds_close_request_type,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_close_request_type, f, c),
  _xsd_handle_ (_xsd_ds_close_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  ds_close_request_type::
  ds_close_request_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_close_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }
  }

  ds_close_request_type* ds_close_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_close_request_type (*this, f, c);
  }

  // ds_close_reply_type
  //

  ds_close_reply_type::
  ds_close_reply_type ()
  : ::xml_schema::type ()
  {
  }

  ds_close_reply_type::
  ds_close_reply_type (const ds_close_reply_type& _xsd_ds_close_reply_type,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_close_reply_type, f, c)
  {
  }

  ds_close_reply_type::
  ds_close_reply_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  ds_close_reply_type::
  ds_close_reply_type (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  ds_close_reply_type::
  ds_close_reply_type (const ::std::basic_string< char >& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  ds_close_reply_type* ds_close_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_close_reply_type (*this, f, c);
  }

  // table_create_request_type
  //

  table_create_request_type::
  table_create_request_type (const handle::type& _xsd_handle,
                             const table::type& _xsd_table,
                             const key::type& _xsd_key,
                             const keytype::type& _xsd_keytype)
  : ::xml_schema::type (),
  _xsd_field_ (::xml_schema::flags (), this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_key_ (_xsd_key,
             ::xml_schema::flags (),
             this),
  _xsd_keytype_ (_xsd_keytype,
                 ::xml_schema::flags (),
                 this)
  {
  }

  table_create_request_type::
  table_create_request_type (const table_create_request_type& _xsd_table_create_request_type,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_create_request_type, f, c),
  _xsd_field_ (_xsd_table_create_request_type._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_handle_ (_xsd_table_create_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_table_create_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_key_ (_xsd_table_create_request_type._xsd_key_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_keytype_ (_xsd_table_create_request_type._xsd_keytype_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  table_create_request_type::
  table_create_request_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_key_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keytype_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_create_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // field
      //
      {
        if (e.name () == "field" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< field::type > r (
            field::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->field ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "key" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< key::type > r (
          key::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->key (r);
        continue;
      }

      if (a.name () == "keytype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keytype::type > r (
          keytype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keytype (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }

    if (!_xsd_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }

    if (!_xsd_keytype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keytype",
        "");
    }
  }

  table_create_request_type* table_create_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_create_request_type (*this, f, c);
  }

  // table_create_reply_type
  //

  table_create_reply_type::
  table_create_reply_type ()
  : ::xml_schema::type ()
  {
  }

  table_create_reply_type::
  table_create_reply_type (const table_create_reply_type& _xsd_table_create_reply_type,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_create_reply_type, f, c)
  {
  }

  table_create_reply_type::
  table_create_reply_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  table_create_reply_type::
  table_create_reply_type (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  table_create_reply_type::
  table_create_reply_type (const ::std::basic_string< char >& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  table_create_reply_type* table_create_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_create_reply_type (*this, f, c);
  }

  // table_del_request_type
  //

  table_del_request_type::
  table_del_request_type (const handle::type& _xsd_handle,
                          const table::type& _xsd_table)
  : ::xml_schema::type (),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this)
  {
  }

  table_del_request_type::
  table_del_request_type (const table_del_request_type& _xsd_table_del_request_type,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_del_request_type, f, c),
  _xsd_handle_ (_xsd_table_del_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_table_del_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  table_del_request_type::
  table_del_request_type (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_del_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }
  }

  table_del_request_type* table_del_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_del_request_type (*this, f, c);
  }

  // table_del_reply_type
  //

  table_del_reply_type::
  table_del_reply_type ()
  : ::xml_schema::type ()
  {
  }

  table_del_reply_type::
  table_del_reply_type (const table_del_reply_type& _xsd_table_del_reply_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_del_reply_type, f, c)
  {
  }

  table_del_reply_type::
  table_del_reply_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  table_del_reply_type::
  table_del_reply_type (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  table_del_reply_type::
  table_del_reply_type (const ::std::basic_string< char >& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  table_del_reply_type* table_del_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_del_reply_type (*this, f, c);
  }

  // table_stat_request_type
  //

  table_stat_request_type::
  table_stat_request_type (const handle::type& _xsd_handle,
                           const table::type& _xsd_table)
  : ::xml_schema::type (),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this)
  {
  }

  table_stat_request_type::
  table_stat_request_type (const table_stat_request_type& _xsd_table_stat_request_type,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_stat_request_type, f, c),
  _xsd_handle_ (_xsd_table_stat_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_table_stat_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  table_stat_request_type::
  table_stat_request_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_stat_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }
  }

  table_stat_request_type* table_stat_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_stat_request_type (*this, f, c);
  }

  // table_stat_reply_type
  //

  table_stat_reply_type::
  table_stat_reply_type (const keyname::type& _xsd_keyname,
                         const keytype::type& _xsd_keytype,
                         const count::type& _xsd_count)
  : ::xml_schema::type (),
  _xsd_field_ (::xml_schema::flags (), this),
  _xsd_keyname_ (_xsd_keyname,
                 ::xml_schema::flags (),
                 this),
  _xsd_keytype_ (_xsd_keytype,
                 ::xml_schema::flags (),
                 this),
  _xsd_count_ (_xsd_count,
               ::xml_schema::flags (),
               this)
  {
  }

  table_stat_reply_type::
  table_stat_reply_type (const table_stat_reply_type& _xsd_table_stat_reply_type,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_stat_reply_type, f, c),
  _xsd_field_ (_xsd_table_stat_reply_type._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_keyname_ (_xsd_table_stat_reply_type._xsd_keyname_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_keytype_ (_xsd_table_stat_reply_type._xsd_keytype_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_count_ (_xsd_table_stat_reply_type._xsd_count_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  table_stat_reply_type::
  table_stat_reply_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keyname_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keytype_ (f | ::xml_schema::flags::not_root, this),
  _xsd_count_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_stat_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // field
      //
      {
        if (e.name () == "field" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< field::type > r (
            field::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->field ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "keyname" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keyname::type > r (
          keyname::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keyname (r);
        continue;
      }

      if (a.name () == "keytype" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keytype::type > r (
          keytype::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keytype (r);
        continue;
      }

      if (a.name () == "count" && a.namespace_ ().empty ())
      {
        this->count (
          count::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    if (!_xsd_keyname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keyname",
        "");
    }

    if (!_xsd_keytype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keytype",
        "");
    }

    if (!_xsd_count_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "count",
        "");
    }
  }

  table_stat_reply_type* table_stat_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_stat_reply_type (*this, f, c);
  }

  // table_keys_request_type
  //

  table_keys_request_type::
  table_keys_request_type (const handle::type& _xsd_handle,
                           const table::type& _xsd_table,
                           const keyname::type& _xsd_keyname)
  : ::xml_schema::type (),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_keyname_ (_xsd_keyname,
                 ::xml_schema::flags (),
                 this)
  {
  }

  table_keys_request_type::
  table_keys_request_type (const table_keys_request_type& _xsd_table_keys_request_type,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_keys_request_type, f, c),
  _xsd_handle_ (_xsd_table_keys_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_table_keys_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_keyname_ (_xsd_table_keys_request_type._xsd_keyname_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  table_keys_request_type::
  table_keys_request_type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keyname_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_keys_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "keyname" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keyname::type > r (
          keyname::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keyname (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }

    if (!_xsd_keyname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keyname",
        "");
    }
  }

  table_keys_request_type* table_keys_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_keys_request_type (*this, f, c);
  }

  // table_keys_reply_type
  //

  table_keys_reply_type::
  table_keys_reply_type ()
  : ::xml_schema::type (),
  _xsd_key_ (::xml_schema::flags (), this)
  {
  }

  table_keys_reply_type::
  table_keys_reply_type (const table_keys_reply_type& _xsd_table_keys_reply_type,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_table_keys_reply_type, f, c),
  _xsd_key_ (_xsd_table_keys_reply_type._xsd_key_,
             f | ::xml_schema::flags::not_root,
             this)
  {
  }

  table_keys_reply_type::
  table_keys_reply_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_key_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void table_keys_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // key
      //
      {
        if (e.name () == "key" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< key::type > r (
            key::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->key ().push_back (r);
          continue;
        }
      }
    }
  }

  table_keys_reply_type* table_keys_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new table_keys_reply_type (*this, f, c);
  }

  // put_request_type
  //

  put_request_type::
  put_request_type (const key::type& _xsd_key,
                    const handle::type& _xsd_handle,
                    const table::type& _xsd_table,
                    const keyname::type& _xsd_keyname)
  : ::xml_schema::type (),
  _xsd_key_ (_xsd_key,
             ::xml_schema::flags (),
             this),
  _xsd_set_ (::xml_schema::flags (), this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_keyname_ (_xsd_keyname,
                 ::xml_schema::flags (),
                 this)
  {
  }

  put_request_type::
  put_request_type (const put_request_type& _xsd_put_request_type,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_put_request_type, f, c),
  _xsd_key_ (_xsd_put_request_type._xsd_key_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_set_ (_xsd_put_request_type._xsd_set_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_handle_ (_xsd_put_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_put_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_keyname_ (_xsd_put_request_type._xsd_keyname_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  put_request_type::
  put_request_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_key_ (f | ::xml_schema::flags::not_root, this),
  _xsd_set_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keyname_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void put_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // key
      //
      {
        if (e.name () == "key" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< key::type > r (
            key::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_key_.present ())
            continue;
          this->key (r);
          continue;
        }
      }

      // set
      //
      {
        if (e.name () == "set" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< set::type > r (
            set::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->set ().push_back (r);
          continue;
        }
      }
    }

    if (!_xsd_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "key",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "keyname" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keyname::type > r (
          keyname::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keyname (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }

    if (!_xsd_keyname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keyname",
        "");
    }
  }

  put_request_type* put_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new put_request_type (*this, f, c);
  }

  // put_reply_type
  //

  put_reply_type::
  put_reply_type ()
  : ::xml_schema::type ()
  {
  }

  put_reply_type::
  put_reply_type (const put_reply_type& _xsd_put_reply_type,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_put_reply_type, f, c)
  {
  }

  put_reply_type::
  put_reply_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  put_reply_type::
  put_reply_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  put_reply_type::
  put_reply_type (const ::std::basic_string< char >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  put_reply_type* put_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new put_reply_type (*this, f, c);
  }

  // get_request_type
  //

  get_request_type::
  get_request_type (const key::type& _xsd_key,
                    const handle::type& _xsd_handle,
                    const table::type& _xsd_table,
                    const keyname::type& _xsd_keyname)
  : ::xml_schema::type (),
  _xsd_key_ (_xsd_key,
             ::xml_schema::flags (),
             this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_keyname_ (_xsd_keyname,
                 ::xml_schema::flags (),
                 this)
  {
  }

  get_request_type::
  get_request_type (const get_request_type& _xsd_get_request_type,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_get_request_type, f, c),
  _xsd_key_ (_xsd_get_request_type._xsd_key_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_handle_ (_xsd_get_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_get_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_keyname_ (_xsd_get_request_type._xsd_keyname_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  get_request_type::
  get_request_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_key_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keyname_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void get_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // key
      //
      {
        if (e.name () == "key" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< key::type > r (
            key::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_key_.present ())
            continue;
          this->key (r);
          continue;
        }
      }
    }

    if (!_xsd_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "key",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "keyname" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keyname::type > r (
          keyname::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keyname (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }

    if (!_xsd_keyname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keyname",
        "");
    }
  }

  get_request_type* get_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new get_request_type (*this, f, c);
  }

  // get_reply_type
  //

  get_reply_type::
  get_reply_type ()
  : ::xml_schema::type (),
  _xsd_field_ (::xml_schema::flags (), this)
  {
  }

  get_reply_type::
  get_reply_type (const get_reply_type& _xsd_get_reply_type,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_get_reply_type, f, c),
  _xsd_field_ (_xsd_get_reply_type._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  get_reply_type::
  get_reply_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void get_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // field
      //
      {
        if (e.name () == "field" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< field::type > r (
            field::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->field ().push_back (r);
          continue;
        }
      }
    }
  }

  get_reply_type* get_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new get_reply_type (*this, f, c);
  }

  // del_request_type
  //

  del_request_type::
  del_request_type (const key::type& _xsd_key,
                    const handle::type& _xsd_handle,
                    const table::type& _xsd_table,
                    const keyname::type& _xsd_keyname)
  : ::xml_schema::type (),
  _xsd_key_ (_xsd_key,
             ::xml_schema::flags (),
             this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_keyname_ (_xsd_keyname,
                 ::xml_schema::flags (),
                 this)
  {
  }

  del_request_type::
  del_request_type (const del_request_type& _xsd_del_request_type,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_del_request_type, f, c),
  _xsd_key_ (_xsd_del_request_type._xsd_key_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_handle_ (_xsd_del_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_del_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_keyname_ (_xsd_del_request_type._xsd_keyname_,
                 f | ::xml_schema::flags::not_root,
                 this)
  {
  }

  del_request_type::
  del_request_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_key_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_keyname_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void del_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // key
      //
      {
        if (e.name () == "key" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< key::type > r (
            key::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_key_.present ())
            continue;
          this->key (r);
          continue;
        }
      }
    }

    if (!_xsd_key_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "key",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "keyname" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< keyname::type > r (
          keyname::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->keyname (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }

    if (!_xsd_keyname_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "keyname",
        "");
    }
  }

  del_request_type* del_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new del_request_type (*this, f, c);
  }

  // del_reply_type
  //

  del_reply_type::
  del_reply_type ()
  : ::xml_schema::type ()
  {
  }

  del_reply_type::
  del_reply_type (const del_reply_type& _xsd_del_reply_type,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_del_reply_type, f, c)
  {
  }

  del_reply_type::
  del_reply_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c)
  {
  }

  del_reply_type::
  del_reply_type (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (a, f, c)
  {
  }

  del_reply_type::
  del_reply_type (const ::std::basic_string< char >& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
  : ::xml_schema::type (s, e, f, c)
  {
  }

  del_reply_type* del_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new del_reply_type (*this, f, c);
  }

  // select_request_type
  //

  select_request_type::
  select_request_type (const handle::type& _xsd_handle,
                       const table::type& _xsd_table)
  : ::xml_schema::type (),
  _xsd_get_ (::xml_schema::flags (), this),
  _xsd_where_ (::xml_schema::flags (), this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_table_ (_xsd_table,
               ::xml_schema::flags (),
               this),
  _xsd_count_ (::xml_schema::flags (), this)
  {
  }

  select_request_type::
  select_request_type (const select_request_type& _xsd_select_request_type,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_select_request_type, f, c),
  _xsd_get_ (_xsd_select_request_type._xsd_get_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_where_ (_xsd_select_request_type._xsd_where_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_handle_ (_xsd_select_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_table_ (_xsd_select_request_type._xsd_table_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_count_ (_xsd_select_request_type._xsd_count_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  select_request_type::
  select_request_type (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_get_ (f | ::xml_schema::flags::not_root, this),
  _xsd_where_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_ (f | ::xml_schema::flags::not_root, this),
  _xsd_count_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void select_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // get
      //
      {
        if (e.name () == "get" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< get::type > r (
            get::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->get ().push_back (r);
          continue;
        }
      }

      // where
      //
      {
        if (e.name () == "where" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< where::type > r (
            where::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->where ().push_back (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "table" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< table::type > r (
          table::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->table (r);
        continue;
      }

      if (a.name () == "count" && a.namespace_ ().empty ())
      {
        this->count (
          count::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_table_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "table",
        "");
    }
  }

  select_request_type* select_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new select_request_type (*this, f, c);
  }

  // rowType
  //

  rowType::
  rowType ()
  : ::xml_schema::type (),
  _xsd_field_ (::xml_schema::flags (), this)
  {
  }

  rowType::
  rowType (const rowType& _xsd_rowType,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_rowType, f, c),
  _xsd_field_ (_xsd_rowType._xsd_field_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  rowType::
  rowType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_field_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void rowType::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // field
      //
      {
        if (e.name () == "field" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< field::type > r (
            field::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->field ().push_back (r);
          continue;
        }
      }
    }
  }

  rowType* rowType::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new rowType (*this, f, c);
  }

  // select_reply_type
  //

  select_reply_type::
  select_reply_type ()
  : ::xml_schema::type (),
  _xsd_row_ (::xml_schema::flags (), this)
  {
  }

  select_reply_type::
  select_reply_type (const select_reply_type& _xsd_select_reply_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_select_reply_type, f, c),
  _xsd_row_ (_xsd_select_reply_type._xsd_row_,
             f | ::xml_schema::flags::not_root,
             this)
  {
  }

  select_reply_type::
  select_reply_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_row_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void select_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // row
      //
      {
        if (e.name () == "row" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< row::type > r (
            row::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          this->row ().push_back (r);
          continue;
        }
      }
    }
  }

  select_reply_type* select_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new select_reply_type (*this, f, c);
  }

  // eval_request_type
  //

  eval_request_type::
  eval_request_type (const expr::type& _xsd_expr,
                     const handle::type& _xsd_handle,
                     const language::type& _xsd_language)
  : ::xml_schema::type (),
  _xsd_expr_ (_xsd_expr,
              ::xml_schema::flags (),
              this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_language_ (_xsd_language,
                  ::xml_schema::flags (),
                  this)
  {
  }

  eval_request_type::
  eval_request_type (const eval_request_type& _xsd_eval_request_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_eval_request_type, f, c),
  _xsd_expr_ (_xsd_eval_request_type._xsd_expr_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_handle_ (_xsd_eval_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_language_ (_xsd_eval_request_type._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  eval_request_type::
  eval_request_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_expr_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void eval_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // expr
      //
      {
        if (e.name () == "expr" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< expr::type > r (
            expr::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_expr_.present ())
            continue;
          this->expr (r);
          continue;
        }
      }
    }

    if (!_xsd_expr_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "expr",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "language" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< language::type > r (
          language::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->language (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_language_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "language",
        "");
    }
  }

  eval_request_type* eval_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new eval_request_type (*this, f, c);
  }

  // eval_reply_type
  //

  eval_reply_type::
  eval_reply_type (const value::type& _xsd_value,
                   const language::type& _xsd_language)
  : ::xml_schema::type (),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_language_ (_xsd_language,
                  ::xml_schema::flags (),
                  this)
  {
  }

  eval_reply_type::
  eval_reply_type (const eval_reply_type& _xsd_eval_reply_type,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_eval_reply_type, f, c),
  _xsd_value_ (_xsd_eval_reply_type._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_language_ (_xsd_eval_reply_type._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  eval_reply_type::
  eval_reply_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void eval_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // value
      //
      {
        if (e.name () == "value" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< value::type > r (
            value::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_value_.present ())
            continue;
          this->value (r);
          continue;
        }
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "language" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< language::type > r (
          language::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->language (r);
        continue;
      }
    }

    if (!_xsd_language_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "language",
        "");
    }
  }

  eval_reply_type* eval_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new eval_reply_type (*this, f, c);
  }

  // trigger_request_type
  //

  trigger_request_type::
  trigger_request_type (const expr::type& _xsd_expr,
                        const handle::type& _xsd_handle,
                        const language::type& _xsd_language)
  : ::xml_schema::type (),
  _xsd_expr_ (_xsd_expr,
              ::xml_schema::flags (),
              this),
  _xsd_handle_ (_xsd_handle,
                ::xml_schema::flags (),
                this),
  _xsd_language_ (_xsd_language,
                  ::xml_schema::flags (),
                  this)
  {
  }

  trigger_request_type::
  trigger_request_type (const trigger_request_type& _xsd_trigger_request_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_trigger_request_type, f, c),
  _xsd_expr_ (_xsd_trigger_request_type._xsd_expr_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_handle_ (_xsd_trigger_request_type._xsd_handle_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_language_ (_xsd_trigger_request_type._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  trigger_request_type::
  trigger_request_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_expr_ (f | ::xml_schema::flags::not_root, this),
  _xsd_handle_ (f | ::xml_schema::flags::not_root, this),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void trigger_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // expr
      //
      {
        if (e.name () == "expr" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< expr::type > r (
            expr::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_expr_.present ())
            continue;
          this->expr (r);
          continue;
        }
      }
    }

    if (!_xsd_expr_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "expr",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "handle" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< handle::type > r (
          handle::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->handle (r);
        continue;
      }

      if (a.name () == "language" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< language::type > r (
          language::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->language (r);
        continue;
      }
    }

    if (!_xsd_handle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "handle",
        "");
    }

    if (!_xsd_language_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "language",
        "");
    }
  }

  trigger_request_type* trigger_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new trigger_request_type (*this, f, c);
  }

  // trigger_reply_type
  //

  trigger_reply_type::
  trigger_reply_type (const value::type& _xsd_value,
                      const language::type& _xsd_language)
  : ::xml_schema::type (),
  _xsd_value_ (_xsd_value,
               ::xml_schema::flags (),
               this),
  _xsd_language_ (_xsd_language,
                  ::xml_schema::flags (),
                  this)
  {
  }

  trigger_reply_type::
  trigger_reply_type (const trigger_reply_type& _xsd_trigger_reply_type,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_trigger_reply_type, f, c),
  _xsd_value_ (_xsd_trigger_reply_type._xsd_value_,
               f | ::xml_schema::flags::not_root,
               this),
  _xsd_language_ (_xsd_trigger_reply_type._xsd_language_,
                  f | ::xml_schema::flags::not_root,
                  this)
  {
  }

  trigger_reply_type::
  trigger_reply_type (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_value_ (f | ::xml_schema::flags::not_root, this),
  _xsd_language_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void trigger_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // value
      //
      {
        if (e.name () == "value" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< value::type > r (
            value::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (_xsd_value_.present ())
            continue;
          this->value (r);
          continue;
        }
      }
    }

    if (!_xsd_value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "language" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< language::type > r (
          language::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->language (r);
        continue;
      }
    }

    if (!_xsd_language_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "language",
        "");
    }
  }

  trigger_reply_type* trigger_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new trigger_reply_type (*this, f, c);
  }

  // ds_request_type
  //

  ds_request_type::
  ds_request_type (const cookie::type& _xsd_cookie)
  : ::xml_schema::type (),
  _xsd_ds_caps_ (::xml_schema::flags (), this),
  _xsd_ds_create_ (::xml_schema::flags (), this),
  _xsd_ds_del_ (::xml_schema::flags (), this),
  _xsd_ds_open_ (::xml_schema::flags (), this),
  _xsd_ds_stat_ (::xml_schema::flags (), this),
  _xsd_ds_close_ (::xml_schema::flags (), this),
  _xsd_table_create_ (::xml_schema::flags (), this),
  _xsd_table_del_ (::xml_schema::flags (), this),
  _xsd_table_stat_ (::xml_schema::flags (), this),
  _xsd_table_keys_ (::xml_schema::flags (), this),
  _xsd_put_ (::xml_schema::flags (), this),
  _xsd_get_ (::xml_schema::flags (), this),
  _xsd_del_ (::xml_schema::flags (), this),
  _xsd_select_ (::xml_schema::flags (), this),
  _xsd_eval_ (::xml_schema::flags (), this),
  _xsd_trigger_ (::xml_schema::flags (), this),
  _xsd_cookie_ (_xsd_cookie,
                ::xml_schema::flags (),
                this)
  {
  }

  ds_request_type::
  ds_request_type (const ds_request_type& _xsd_ds_request_type,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_request_type, f, c),
  _xsd_ds_caps_ (_xsd_ds_request_type._xsd_ds_caps_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_ds_create_ (_xsd_ds_request_type._xsd_ds_create_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_ds_del_ (_xsd_ds_request_type._xsd_ds_del_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_ds_open_ (_xsd_ds_request_type._xsd_ds_open_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_ds_stat_ (_xsd_ds_request_type._xsd_ds_stat_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_ds_close_ (_xsd_ds_request_type._xsd_ds_close_,
                  f | ::xml_schema::flags::not_root,
                  this),
  _xsd_table_create_ (_xsd_ds_request_type._xsd_table_create_,
                      f | ::xml_schema::flags::not_root,
                      this),
  _xsd_table_del_ (_xsd_ds_request_type._xsd_table_del_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_table_stat_ (_xsd_ds_request_type._xsd_table_stat_,
                    f | ::xml_schema::flags::not_root,
                    this),
  _xsd_table_keys_ (_xsd_ds_request_type._xsd_table_keys_,
                    f | ::xml_schema::flags::not_root,
                    this),
  _xsd_put_ (_xsd_ds_request_type._xsd_put_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_get_ (_xsd_ds_request_type._xsd_get_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_del_ (_xsd_ds_request_type._xsd_del_,
             f | ::xml_schema::flags::not_root,
             this),
  _xsd_select_ (_xsd_ds_request_type._xsd_select_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_eval_ (_xsd_ds_request_type._xsd_eval_,
              f | ::xml_schema::flags::not_root,
              this),
  _xsd_trigger_ (_xsd_ds_request_type._xsd_trigger_,
                 f | ::xml_schema::flags::not_root,
                 this),
  _xsd_cookie_ (_xsd_ds_request_type._xsd_cookie_,
                f | ::xml_schema::flags::not_root,
                this)
  {
  }

  ds_request_type::
  ds_request_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_ds_caps_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_create_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_del_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_open_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_stat_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_close_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_create_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_del_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_stat_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_keys_ (f | ::xml_schema::flags::not_root, this),
  _xsd_put_ (f | ::xml_schema::flags::not_root, this),
  _xsd_get_ (f | ::xml_schema::flags::not_root, this),
  _xsd_del_ (f | ::xml_schema::flags::not_root, this),
  _xsd_select_ (f | ::xml_schema::flags::not_root, this),
  _xsd_eval_ (f | ::xml_schema::flags::not_root, this),
  _xsd_trigger_ (f | ::xml_schema::flags::not_root, this),
  _xsd_cookie_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_request_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // ds_caps
      //
      {
        if (e.name () == "ds-caps" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_caps::type > r (
            ds_caps::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_caps ())
            continue;
          this->ds_caps (r);
          continue;
        }
      }

      // ds_create
      //
      {
        if (e.name () == "ds-create" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_create::type > r (
            ds_create::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_create ())
            continue;
          this->ds_create (r);
          continue;
        }
      }

      // ds_del
      //
      {
        if (e.name () == "ds-del" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_del::type > r (
            ds_del::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_del ())
            continue;
          this->ds_del (r);
          continue;
        }
      }

      // ds_open
      //
      {
        if (e.name () == "ds-open" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_open::type > r (
            ds_open::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_open ())
            continue;
          this->ds_open (r);
          continue;
        }
      }

      // ds_stat
      //
      {
        if (e.name () == "ds-stat" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_stat::type > r (
            ds_stat::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_stat ())
            continue;
          this->ds_stat (r);
          continue;
        }
      }

      // ds_close
      //
      {
        if (e.name () == "ds-close" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_close::type > r (
            ds_close::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_close ())
            continue;
          this->ds_close (r);
          continue;
        }
      }

      // table_create
      //
      {
        if (e.name () == "table-create" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_create::type > r (
            table_create::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_create ())
            continue;
          this->table_create (r);
          continue;
        }
      }

      // table_del
      //
      {
        if (e.name () == "table-del" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_del::type > r (
            table_del::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_del ())
            continue;
          this->table_del (r);
          continue;
        }
      }

      // table_stat
      //
      {
        if (e.name () == "table-stat" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_stat::type > r (
            table_stat::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_stat ())
            continue;
          this->table_stat (r);
          continue;
        }
      }

      // table_keys
      //
      {
        if (e.name () == "table-keys" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_keys::type > r (
            table_keys::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_keys ())
            continue;
          this->table_keys (r);
          continue;
        }
      }

      // put
      //
      {
        if (e.name () == "put" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< put::type > r (
            put::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->put ())
            continue;
          this->put (r);
          continue;
        }
      }

      // get
      //
      {
        if (e.name () == "get" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< get::type > r (
            get::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->get ())
            continue;
          this->get (r);
          continue;
        }
      }

      // del
      //
      {
        if (e.name () == "del" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< del::type > r (
            del::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->del ())
            continue;
          this->del (r);
          continue;
        }
      }

      // select
      //
      {
        if (e.name () == "select" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< select::type > r (
            select::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->select ())
            continue;
          this->select (r);
          continue;
        }
      }

      // eval
      //
      {
        if (e.name () == "eval" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< eval::type > r (
            eval::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->eval ())
            continue;
          this->eval (r);
          continue;
        }
      }

      // trigger
      //
      {
        if (e.name () == "trigger" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< trigger::type > r (
            trigger::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->trigger ())
            continue;
          this->trigger (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "cookie" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< cookie::type > r (
          cookie::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->cookie (r);
        continue;
      }
    }

    if (!_xsd_cookie_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cookie",
        "");
    }
  }

  ds_request_type* ds_request_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_request_type (*this, f, c);
  }

  // ds_reply_type
  //

  ds_reply_type::
  ds_reply_type (const cookie::type& _xsd_cookie,
                 const error::type& _xsd_error)
  : ::xml_schema::type (),
  _xsd_ds_caps_reply_ (::xml_schema::flags (), this),
  _xsd_ds_create_reply_ (::xml_schema::flags (), this),
  _xsd_ds_del_reply_ (::xml_schema::flags (), this),
  _xsd_ds_open_reply_ (::xml_schema::flags (), this),
  _xsd_ds_stat_reply_ (::xml_schema::flags (), this),
  _xsd_ds_close_reply_ (::xml_schema::flags (), this),
  _xsd_table_create_reply_ (::xml_schema::flags (), this),
  _xsd_table_del_reply_ (::xml_schema::flags (), this),
  _xsd_table_stat_reply_ (::xml_schema::flags (), this),
  _xsd_table_keys_reply_ (::xml_schema::flags (), this),
  _xsd_put_reply_ (::xml_schema::flags (), this),
  _xsd_get_reply_ (::xml_schema::flags (), this),
  _xsd_del_reply_ (::xml_schema::flags (), this),
  _xsd_select_reply_ (::xml_schema::flags (), this),
  _xsd_eval_reply_ (::xml_schema::flags (), this),
  _xsd_trigger_reply_ (::xml_schema::flags (), this),
  _xsd_cookie_ (_xsd_cookie,
                ::xml_schema::flags (),
                this),
  _xsd_error_ (_xsd_error,
               ::xml_schema::flags (),
               this)
  {
  }

  ds_reply_type::
  ds_reply_type (const ds_reply_type& _xsd_ds_reply_type,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (_xsd_ds_reply_type, f, c),
  _xsd_ds_caps_reply_ (_xsd_ds_reply_type._xsd_ds_caps_reply_,
                       f | ::xml_schema::flags::not_root,
                       this),
  _xsd_ds_create_reply_ (_xsd_ds_reply_type._xsd_ds_create_reply_,
                         f | ::xml_schema::flags::not_root,
                         this),
  _xsd_ds_del_reply_ (_xsd_ds_reply_type._xsd_ds_del_reply_,
                      f | ::xml_schema::flags::not_root,
                      this),
  _xsd_ds_open_reply_ (_xsd_ds_reply_type._xsd_ds_open_reply_,
                       f | ::xml_schema::flags::not_root,
                       this),
  _xsd_ds_stat_reply_ (_xsd_ds_reply_type._xsd_ds_stat_reply_,
                       f | ::xml_schema::flags::not_root,
                       this),
  _xsd_ds_close_reply_ (_xsd_ds_reply_type._xsd_ds_close_reply_,
                        f | ::xml_schema::flags::not_root,
                        this),
  _xsd_table_create_reply_ (_xsd_ds_reply_type._xsd_table_create_reply_,
                            f | ::xml_schema::flags::not_root,
                            this),
  _xsd_table_del_reply_ (_xsd_ds_reply_type._xsd_table_del_reply_,
                         f | ::xml_schema::flags::not_root,
                         this),
  _xsd_table_stat_reply_ (_xsd_ds_reply_type._xsd_table_stat_reply_,
                          f | ::xml_schema::flags::not_root,
                          this),
  _xsd_table_keys_reply_ (_xsd_ds_reply_type._xsd_table_keys_reply_,
                          f | ::xml_schema::flags::not_root,
                          this),
  _xsd_put_reply_ (_xsd_ds_reply_type._xsd_put_reply_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_get_reply_ (_xsd_ds_reply_type._xsd_get_reply_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_del_reply_ (_xsd_ds_reply_type._xsd_del_reply_,
                   f | ::xml_schema::flags::not_root,
                   this),
  _xsd_select_reply_ (_xsd_ds_reply_type._xsd_select_reply_,
                      f | ::xml_schema::flags::not_root,
                      this),
  _xsd_eval_reply_ (_xsd_ds_reply_type._xsd_eval_reply_,
                    f | ::xml_schema::flags::not_root,
                    this),
  _xsd_trigger_reply_ (_xsd_ds_reply_type._xsd_trigger_reply_,
                       f | ::xml_schema::flags::not_root,
                       this),
  _xsd_cookie_ (_xsd_ds_reply_type._xsd_cookie_,
                f | ::xml_schema::flags::not_root,
                this),
  _xsd_error_ (_xsd_ds_reply_type._xsd_error_,
               f | ::xml_schema::flags::not_root,
               this)
  {
  }

  ds_reply_type::
  ds_reply_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
  : ::xml_schema::type (e, f, c),
  _xsd_ds_caps_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_create_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_del_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_open_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_stat_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_ds_close_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_create_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_del_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_stat_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_table_keys_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_put_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_get_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_del_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_select_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_eval_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_trigger_reply_ (f | ::xml_schema::flags::not_root, this),
  _xsd_cookie_ (f | ::xml_schema::flags::not_root, this),
  _xsd_error_ (f | ::xml_schema::flags::not_root, this)
  {
    parse (e, f);
  }

  void ds_reply_type::
  parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);

    while (p.more_elements ())
    {
      const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

      // ds_caps_reply
      //
      {
        if (e.name () == "ds-caps-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_caps_reply::type > r (
            ds_caps_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_caps_reply ())
            continue;
          this->ds_caps_reply (r);
          continue;
        }
      }

      // ds_create_reply
      //
      {
        if (e.name () == "ds-create-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_create_reply::type > r (
            ds_create_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_create_reply ())
            continue;
          this->ds_create_reply (r);
          continue;
        }
      }

      // ds_del_reply
      //
      {
        if (e.name () == "ds-del-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_del_reply::type > r (
            ds_del_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_del_reply ())
            continue;
          this->ds_del_reply (r);
          continue;
        }
      }

      // ds_open_reply
      //
      {
        if (e.name () == "ds-open-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_open_reply::type > r (
            ds_open_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_open_reply ())
            continue;
          this->ds_open_reply (r);
          continue;
        }
      }

      // ds_stat_reply
      //
      {
        if (e.name () == "ds-stat-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_stat_reply::type > r (
            ds_stat_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_stat_reply ())
            continue;
          this->ds_stat_reply (r);
          continue;
        }
      }

      // ds_close_reply
      //
      {
        if (e.name () == "ds-close-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< ds_close_reply::type > r (
            ds_close_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->ds_close_reply ())
            continue;
          this->ds_close_reply (r);
          continue;
        }
      }

      // table_create_reply
      //
      {
        if (e.name () == "table-create-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_create_reply::type > r (
            table_create_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_create_reply ())
            continue;
          this->table_create_reply (r);
          continue;
        }
      }

      // table_del_reply
      //
      {
        if (e.name () == "table-del-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_del_reply::type > r (
            table_del_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_del_reply ())
            continue;
          this->table_del_reply (r);
          continue;
        }
      }

      // table_stat_reply
      //
      {
        if (e.name () == "table-stat-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_stat_reply::type > r (
            table_stat_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_stat_reply ())
            continue;
          this->table_stat_reply (r);
          continue;
        }
      }

      // table_keys_reply
      //
      {
        if (e.name () == "table-keys-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< table_keys_reply::type > r (
            table_keys_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->table_keys_reply ())
            continue;
          this->table_keys_reply (r);
          continue;
        }
      }

      // put_reply
      //
      {
        if (e.name () == "put-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< put_reply::type > r (
            put_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->put_reply ())
            continue;
          this->put_reply (r);
          continue;
        }
      }

      // get_reply
      //
      {
        if (e.name () == "get-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< get_reply::type > r (
            get_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->get_reply ())
            continue;
          this->get_reply (r);
          continue;
        }
      }

      // del_reply
      //
      {
        if (e.name () == "del-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< del_reply::type > r (
            del_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->del_reply ())
            continue;
          this->del_reply (r);
          continue;
        }
      }

      // select_reply
      //
      {
        if (e.name () == "select-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< select_reply::type > r (
            select_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->select_reply ())
            continue;
          this->select_reply (r);
          continue;
        }
      }

      // eval_reply
      //
      {
        if (e.name () == "eval-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< eval_reply::type > r (
            eval_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->eval_reply ())
            continue;
          this->eval_reply (r);
          continue;
        }
      }

      // trigger_reply
      //
      {
        if (e.name () == "trigger-reply" && e.namespace_ ().empty ())
        {
          ::std::auto_ptr< trigger_reply::type > r (
            trigger_reply::traits::create (
              e.dom_element (),
              f | ::xml_schema::flags::not_root,
              this));

          if (this->trigger_reply ())
            continue;
          this->trigger_reply (r);
          continue;
        }
      }
    }

    while (p.more_attributes ())
    {
      const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

      if (a.name () == "cookie" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< cookie::type > r (
          cookie::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->cookie (r);
        continue;
      }

      if (a.name () == "error" && a.namespace_ ().empty ())
      {
        ::std::auto_ptr< error::type > r (
          error::traits::create (
            a.dom_attribute (),
            f | ::xml_schema::flags::not_root,
            this));

        this->error (r);
        continue;
      }
    }

    if (!_xsd_cookie_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "cookie",
        "");
    }

    if (!_xsd_error_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "error",
        "");
    }
  }

  ds_reply_type* ds_reply_type::
  _clone (::xml_schema::flags f,
          ::xml_schema::type* c) const
  {
    return new ds_reply_type (*this, f, c);
  }
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dsmessage
{
  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::std::basic_string< char >& u,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::std::basic_string< char >& u,
              ::xsd::cxx::xml::error_handler< char >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::std::basic_string< char >& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              ::xsd::cxx::xml::error_handler< char >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              const ::std::basic_string< char >& sid,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              const ::std::basic_string< char >& sid,
              ::xsd::cxx::xml::error_handler< char >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (::std::istream& is,
              const ::std::basic_string< char >& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_request (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::xercesc::DOMInputSource& i,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::xercesc::DOMInputSource& i,
              ::xsd::cxx::xml::error_handler< char >& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::xercesc::DOMInputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_request (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_request_type >
  ds_request (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xsd::cxx::tree::properties< char >&)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
      (f & ::xml_schema::flags::keep_dom) 
      ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
      : 0);

    const ::xsd::cxx::xml::dom::element< char > e (
      c.get ()
      ? *c->getDocumentElement ()
      : *d.getDocumentElement ());

    if (e.name () == "ds-request" &&
        e.namespace_ () == "")
    {
      ::std::auto_ptr< ::dsmessage::ds_request_type > r (
        ::xsd::cxx::tree::traits< ::dsmessage::ds_request_type, char >::create (
          e.dom_element (), f, 0));
      if (f & ::xml_schema::flags::keep_dom) c.release ();
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      e.name (),
      e.namespace_ (),
      "ds-request",
      "");
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::std::basic_string< char >& u,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::std::basic_string< char >& u,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::std::basic_string< char >& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (::std::istream& is,
            const ::std::basic_string< char >& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    ::xercesc::Wrapper4InputSource wrap (&isrc, false);
    return ::dsmessage::ds_reply (wrap, h, f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::xercesc::DOMInputSource& i,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::xercesc::DOMInputSource& i,
            ::xsd::cxx::xml::error_handler< char >& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::xercesc::DOMInputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >& p)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

    if (!d)
    {
      throw ::xsd::cxx::tree::parsing< char > ();
    }

    return ::dsmessage::ds_reply (
      static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
  }

  ::std::auto_ptr< ::dsmessage::ds_reply_type >
  ds_reply (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xsd::cxx::tree::properties< char >&)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
      (f & ::xml_schema::flags::keep_dom) 
      ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
      : 0);

    const ::xsd::cxx::xml::dom::element< char > e (
      c.get ()
      ? *c->getDocumentElement ()
      : *d.getDocumentElement ());

    if (e.name () == "ds-reply" &&
        e.namespace_ () == "")
    {
      ::std::auto_ptr< ::dsmessage::ds_reply_type > r (
        ::xsd::cxx::tree::traits< ::dsmessage::ds_reply_type, char >::create (
          e.dom_element (), f, 0));
      if (f & ::xml_schema::flags::keep_dom) c.release ();
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      e.name (),
      e.namespace_ (),
      "ds-reply",
      "");
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dsmessage
{
  void
  operator<< (::xercesc::DOMElement& e,
              storeType i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              storeType i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              storeType i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const tableInfoType& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              fieldType i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a,
              fieldType i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >& l,
              fieldType i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const fieldInfoType& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "field",
        e);

      a.dom_attribute () << i.field ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "type",
        e);

      a.dom_attribute () << i.type ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const fieldNameValue& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "value",
        e);
      s.dom_element () << i.value ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "field",
        e);

      a.dom_attribute () << i.field ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const fieldName& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "field",
        e);

      a.dom_attribute () << i.field ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const languageName& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "language",
        e);

      a.dom_attribute () << i.language ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_caps_request_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const ds_caps_request_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const ds_caps_request_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_caps_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (ds_caps_reply_type::language::const_iterator
           b (i.language ().begin ()), n (i.language ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "language",
          e);
        s.dom_element () << *b;
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "storetype",
        e);

      a.dom_attribute () << i.storetype ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "supports-trigger",
        e);

      a.dom_attribute () << i.supports_trigger ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_create_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.password ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "password",
          e);
        s.dom_element () << *i.password ();
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ds",
        e);

      a.dom_attribute () << i.ds ();
    }

    if (i.clear ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "clear",
        e);

      a.dom_attribute () << *i.clear ();
    }

    if (i.quota ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "quota",
        e);

      a.dom_attribute () << *i.quota ();
    }

    if (i.user ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "user",
        e);

      a.dom_attribute () << *i.user ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_create_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const ds_create_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const ds_create_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_del_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.password ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "password",
          e);
        s.dom_element () << *i.password ();
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ds",
        e);

      a.dom_attribute () << i.ds ();
    }

    if (i.user ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "user",
        e);

      a.dom_attribute () << *i.user ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_del_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const ds_del_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const ds_del_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_open_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.password ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "password",
          e);
        s.dom_element () << *i.password ();
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "ds",
        e);

      a.dom_attribute () << i.ds ();
    }

    if (i.lease ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "lease",
        e);

      a.dom_attribute () << *i.lease ();
    }

    if (i.user ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "user",
        e);

      a.dom_attribute () << *i.user ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_open_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    if (i.handle ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << *i.handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_stat_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_stat_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (ds_stat_reply_type::table::const_iterator
           b (i.table ().begin ()), n (i.table ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_close_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_close_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const ds_close_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const ds_close_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_create_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (table_create_request_type::field::const_iterator
           b (i.field ().begin ()), n (i.field ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "field",
          e);
        s.dom_element () << *b;
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "key",
        e);

      a.dom_attribute () << i.key ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keytype",
        e);

      a.dom_attribute () << i.keytype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_create_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const table_create_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const table_create_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_del_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_del_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const table_del_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const table_del_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_stat_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_stat_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (table_stat_reply_type::field::const_iterator
           b (i.field ().begin ()), n (i.field ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "field",
          e);
        s.dom_element () << *b;
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keyname",
        e);

      a.dom_attribute () << i.keyname ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keytype",
        e);

      a.dom_attribute () << i.keytype ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "count",
        e);

      a.dom_attribute () << i.count ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_keys_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keyname",
        e);

      a.dom_attribute () << i.keyname ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const table_keys_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (table_keys_reply_type::key::const_iterator
           b (i.key ().begin ()), n (i.key ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "key",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const put_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "key",
        e);
      s.dom_element () << i.key ();
    }

    {
      for (put_request_type::set::const_iterator
           b (i.set ().begin ()), n (i.set ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "set",
          e);
        s.dom_element () << *b;
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keyname",
        e);

      a.dom_attribute () << i.keyname ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const put_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const put_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const put_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const get_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "key",
        e);
      s.dom_element () << i.key ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keyname",
        e);

      a.dom_attribute () << i.keyname ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const get_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (get_reply_type::field::const_iterator
           b (i.field ().begin ()), n (i.field ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "field",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const del_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "key",
        e);
      s.dom_element () << i.key ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "keyname",
        e);

      a.dom_attribute () << i.keyname ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const del_reply_type&)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);
  }

  void
  operator<< (::xercesc::DOMAttr&,
              const del_reply_type&)
  {
  }

  void
  operator<< (::xsd::cxx::tree::list_stream< char >&,
              const del_reply_type&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const select_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (select_request_type::get::const_iterator
           b (i.get ().begin ()), n (i.get ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "get",
          e);
        s.dom_element () << *b;
      }
    }

    {
      for (select_request_type::where::const_iterator
           b (i.where ().begin ()), n (i.where ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "where",
          e);
        s.dom_element () << *b;
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "table",
        e);

      a.dom_attribute () << i.table ();
    }

    if (i.count ())
    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "count",
        e);

      a.dom_attribute () << *i.count ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const rowType& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (rowType::field::const_iterator
           b (i.field ().begin ()), n (i.field ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "field",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const select_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      for (select_reply_type::row::const_iterator
           b (i.row ().begin ()), n (i.row ().end ());
           b != n; ++b)
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "row",
          e);
        s.dom_element () << *b;
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const eval_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "expr",
        e);
      s.dom_element () << i.expr ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "language",
        e);

      a.dom_attribute () << i.language ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const eval_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "value",
        e);
      s.dom_element () << i.value ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "language",
        e);

      a.dom_attribute () << i.language ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const trigger_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "expr",
        e);
      s.dom_element () << i.expr ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "handle",
        e);

      a.dom_attribute () << i.handle ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "language",
        e);

      a.dom_attribute () << i.language ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const trigger_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      ::xsd::cxx::xml::dom::element< char > s (
        "value",
        e);
      s.dom_element () << i.value ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "language",
        e);

      a.dom_attribute () << i.language ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_request_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.ds_caps ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-caps",
          e);
        s.dom_element () << *i.ds_caps ();
      }
    }

    {
      if (i.ds_create ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-create",
          e);
        s.dom_element () << *i.ds_create ();
      }
    }

    {
      if (i.ds_del ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-del",
          e);
        s.dom_element () << *i.ds_del ();
      }
    }

    {
      if (i.ds_open ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-open",
          e);
        s.dom_element () << *i.ds_open ();
      }
    }

    {
      if (i.ds_stat ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-stat",
          e);
        s.dom_element () << *i.ds_stat ();
      }
    }

    {
      if (i.ds_close ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-close",
          e);
        s.dom_element () << *i.ds_close ();
      }
    }

    {
      if (i.table_create ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-create",
          e);
        s.dom_element () << *i.table_create ();
      }
    }

    {
      if (i.table_del ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-del",
          e);
        s.dom_element () << *i.table_del ();
      }
    }

    {
      if (i.table_stat ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-stat",
          e);
        s.dom_element () << *i.table_stat ();
      }
    }

    {
      if (i.table_keys ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-keys",
          e);
        s.dom_element () << *i.table_keys ();
      }
    }

    {
      if (i.put ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "put",
          e);
        s.dom_element () << *i.put ();
      }
    }

    {
      if (i.get ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "get",
          e);
        s.dom_element () << *i.get ();
      }
    }

    {
      if (i.del ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "del",
          e);
        s.dom_element () << *i.del ();
      }
    }

    {
      if (i.select ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "select",
          e);
        s.dom_element () << *i.select ();
      }
    }

    {
      if (i.eval ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "eval",
          e);
        s.dom_element () << *i.eval ();
      }
    }

    {
      if (i.trigger ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "trigger",
          e);
        s.dom_element () << *i.trigger ();
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "cookie",
        e);

      a.dom_attribute () << i.cookie ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e,
              const ds_reply_type& i)
  {
    while (::xercesc::DOMNode* n = e.getFirstChild ())
      e.removeChild (n);

    {
      if (i.ds_caps_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-caps-reply",
          e);
        s.dom_element () << *i.ds_caps_reply ();
      }
    }

    {
      if (i.ds_create_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-create-reply",
          e);
        s.dom_element () << *i.ds_create_reply ();
      }
    }

    {
      if (i.ds_del_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-del-reply",
          e);
        s.dom_element () << *i.ds_del_reply ();
      }
    }

    {
      if (i.ds_open_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-open-reply",
          e);
        s.dom_element () << *i.ds_open_reply ();
      }
    }

    {
      if (i.ds_stat_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-stat-reply",
          e);
        s.dom_element () << *i.ds_stat_reply ();
      }
    }

    {
      if (i.ds_close_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "ds-close-reply",
          e);
        s.dom_element () << *i.ds_close_reply ();
      }
    }

    {
      if (i.table_create_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-create-reply",
          e);
        s.dom_element () << *i.table_create_reply ();
      }
    }

    {
      if (i.table_del_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-del-reply",
          e);
        s.dom_element () << *i.table_del_reply ();
      }
    }

    {
      if (i.table_stat_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-stat-reply",
          e);
        s.dom_element () << *i.table_stat_reply ();
      }
    }

    {
      if (i.table_keys_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "table-keys-reply",
          e);
        s.dom_element () << *i.table_keys_reply ();
      }
    }

    {
      if (i.put_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "put-reply",
          e);
        s.dom_element () << *i.put_reply ();
      }
    }

    {
      if (i.get_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "get-reply",
          e);
        s.dom_element () << *i.get_reply ();
      }
    }

    {
      if (i.del_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "del-reply",
          e);
        s.dom_element () << *i.del_reply ();
      }
    }

    {
      if (i.select_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "select-reply",
          e);
        s.dom_element () << *i.select_reply ();
      }
    }

    {
      if (i.eval_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "eval-reply",
          e);
        s.dom_element () << *i.eval_reply ();
      }
    }

    {
      if (i.trigger_reply ())
      {
        ::xsd::cxx::xml::dom::element< char > s (
          "trigger-reply",
          e);
        s.dom_element () << *i.trigger_reply ();
      }
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "cookie",
        e);

      a.dom_attribute () << i.cookie ();
    }

    {
      ::xsd::cxx::xml::dom::attribute< char > a (
        "error",
        e);

      a.dom_attribute () << i.error ();
    }
  }

  void
  ds_request (::xercesc::DOMDocument& d,
              const ::dsmessage::ds_request_type& s,
              ::xml_schema::flags)
  {
    ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

    if (e.name () == "ds-request" &&
        e.namespace_ () == "")
    {
      e.dom_element () << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "ds-request",
        "");
    }
  }

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
  ds_request (const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              ::xml_schema::flags f)
  {
    try
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "ds-request",
          "",
          m,
          f));
      ::dsmessage::ds_request (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  ds_request (::xercesc::XMLFormatTarget& t,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ds_request (::xercesc::XMLFormatTarget& t,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              ::xsd::cxx::xml::error_handler< char >& h,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_request (::xercesc::XMLFormatTarget& t,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_request (::std::ostream& o,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ds_request (::std::ostream& o,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              ::xsd::cxx::xml::error_handler< char >& h,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_request (::std::ostream& o,
              const ::dsmessage::ds_request_type& s,
              const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
              ::xercesc::DOMErrorHandler& h,
              const ::std::basic_string< char >& e,
              ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_request (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_reply (::xercesc::DOMDocument& d,
            const ::dsmessage::ds_reply_type& s,
            ::xml_schema::flags)
  {
    ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

    if (e.name () == "ds-reply" &&
        e.namespace_ () == "")
    {
      e.dom_element () << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        e.name (),
        e.namespace_ (),
        "ds-reply",
        "");
    }
  }

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
  ds_reply (const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xml_schema::flags f)
  {
    try
    {
      ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< char > (
          "ds-reply",
          "",
          m,
          f));
      ::dsmessage::ds_reply (*d, s, f);
      return d;
    }
    catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
    {
      throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
    }
    catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
    {
      throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
    }
  }

  void
  ds_reply (::xercesc::XMLFormatTarget& t,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ds_reply (::xercesc::XMLFormatTarget& t,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_reply (::xercesc::XMLFormatTarget& t,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_reply (::std::ostream& o,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ds_reply (::std::ostream& o,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xsd::cxx::xml::error_handler< char >& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ds_reply (::std::ostream& o,
            const ::dsmessage::ds_reply_type& s,
            const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
            ::xercesc::DOMErrorHandler& h,
            const ::std::basic_string< char >& e,
            ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsmessage::ds_reply (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#endif
//
// End epilogue.

